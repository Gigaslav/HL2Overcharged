//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Weapon data file parsing, shared by game & client dlls.
//
// $NoKeywords: $
//=============================================================================//
#include "cbase.h"
#include <KeyValues.h>
#include <tier0/mem.h>
#include "filesystem.h"
#include "utldict.h"
#include "ammodef.h"
#include "gamestringpool.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

#define WEAPONTYPE_SIZE TYPE_LAST+1
const char* WeaponTypeMappedList[WEAPONTYPE_SIZE] =
{
	"None",
	"melee",
	"pistol",
	"dual_pistols",
	"dual_machineguns",
	"smg",
	"AirboatGun",
	"shotgun",
	"annabelle",
	"beam",
	"rpg",
	"grenade"
};

#define ACTIVITY_SIZE LAST_SHARED_ACTIVITY+1
const char* ActivityMappedList[ACTIVITY_SIZE] =
{
	"None",
	"ACT_IDLE",
	"ACT_TRANSITION",
	"ACT_COVER",
	"ACT_COVER_MED",
	"ACT_COVER_LOW",
	"ACT_WALK",
	"ACT_WALK_AIM",
	"ACT_WALK_CROUCH",
	"ACT_WALK_CROUCH_AIM",
	"ACT_RUN",
	"ACT_RUN_AIM",
	"ACT_RUN_CROUCH",
	"ACT_RUN_CROUCH_AIM",
	"ACT_RUN_PROTECTED",
	"ACT_SCRIPT_CUSTOM_MOVE",
	"ACT_RANGE_ATTACK1",
	"ACT_RANGE_ATTACK2",
	"ACT_RANGE_ATTACK1_LOW",
	"ACT_RANGE_ATTACK2_LOW",
	"ACT_DIESIMPLE",
	"ACT_DIEBACKWARD",
	"ACT_DIEFORWARD",
	"ACT_DIEVIOLENT",
	"ACT_DIERAGDOLL",
	"ACT_FLY",
	"ACT_HOVER",
	"ACT_GLIDE",
	"ACT_SWIM",
	"ACT_JUMP",
	"ACT_HOP",
	"ACT_LEAP",
	"ACT_LAND",
	"ACT_CLIMB_UP",
	"ACT_CLIMB_DOWN",
	"ACT_CLIMB_DISMOUNT",
	"ACT_SHIPLADDER_UP",
	"ACT_SHIPLADDER_DOWN",
	"ACT_STRAFE_LEFT",
	"ACT_STRAFE_RIGHT",
	"ACT_ROLL_LEFT",
	"ACT_ROLL_RIGHT",
	"ACT_TURN_LEFT",
	"ACT_TURN_RIGHT",
	"ACT_CROUCH",
	"ACT_CROUCHIDLE",
	"ACT_STAND",
	"ACT_USE",
	"ACT_SIGNAL1",
	"ACT_SIGNAL2",
	"ACT_SIGNAL3",
	"ACT_SIGNAL_ADVANCE",
	"ACT_SIGNAL_FORWARD",
	"ACT_SIGNAL_GROUP",
	"ACT_SIGNAL_HALT",
	"ACT_SIGNAL_LEFT",
	"ACT_SIGNAL_RIGHT",
	"ACT_SIGNAL_TAKECOVER",
	"ACT_LOOKBACK_RIGHT",
	"ACT_LOOKBACK_LEFT",
	"ACT_COWER",
	"ACT_SMALL_FLINCH",
	"ACT_BIG_FLINCH",
	"ACT_MELEE_ATTACK1",
	"ACT_MELEE_ATTACK2",
	"ACT_RELOAD",
	"ACT_RELOAD_START",
	"ACT_RELOAD_FINISH",
	"ACT_RELOAD_LOW",
	"ACT_ARM",
	"ACT_DISARM",
	"ACT_DROP_WEAPON",
	"ACT_DROP_WEAPON_SHOTGUN",
	"ACT_PICKUP_GROUND",
	"ACT_PICKUP_RACK",
	"ACT_IDLE_ANGRY",
	"ACT_IDLE_RELAXED",
	"ACT_IDLE_STIMULATED",
	"ACT_IDLE_AGITATED",
	"ACT_IDLE_STEALTH",
	"ACT_IDLE_HURT",
	"ACT_WALK_RELAXED",
	"ACT_WALK_STIMULATED",
	"ACT_WALK_AGITATED",
	"ACT_WALK_STEALTH",
	"ACT_RUN_RELAXED",
	"ACT_RUN_STIMULATED",
	"ACT_RUN_AGITATED",
	"ACT_RUN_STEALTH",
	"ACT_IDLE_AIM_RELAXED",
	"ACT_IDLE_AIM_STIMULATED",
	"ACT_IDLE_AIM_AGITATED",
	"ACT_IDLE_AIM_STEALTH",
	"ACT_WALK_AIM_RELAXED",
	"ACT_WALK_AIM_STIMULATED",
	"ACT_WALK_AIM_AGITATED",
	"ACT_WALK_AIM_STEALTH",
	"ACT_RUN_AIM_RELAXED",
	"ACT_RUN_AIM_STIMULATED",
	"ACT_RUN_AIM_AGITATED",
	"ACT_RUN_AIM_STEALTH",
	"ACT_CROUCHIDLE_STIMULATED",
	"ACT_CROUCHIDLE_AIM_STIMULATED",
	"ACT_CROUCHIDLE_AGITATED",
	"ACT_WALK_HURT",
	"ACT_RUN_HURT",
	"ACT_SPECIAL_ATTACK1",
	"ACT_SPECIAL_ATTACK2",
	"ACT_COMBAT_IDLE",
	"ACT_WALK_SCARED",
	"ACT_RUN_SCARED",
	"ACT_VICTORY_DANCE",
	"ACT_DIE_HEADSHOT",
	"ACT_DIE_CHESTSHOT",
	"ACT_DIE_GUTSHOT",
	"ACT_DIE_BACKSHOT",
	"ACT_FLINCH_HEAD",
	"ACT_FLINCH_CHEST",
	"ACT_FLINCH_STOMACH",
	"ACT_FLINCH_LEFTARM",
	"ACT_FLINCH_RIGHTARM",
	"ACT_FLINCH_LEFTLEG",
	"ACT_FLINCH_RIGHTLEG",
	"ACT_FLINCH_PHYSICS",
	"ACT_IDLE_ON_FIRE",
	"ACT_WALK_ON_FIRE",
	"ACT_RUN_ON_FIRE",
	"ACT_RAPPEL_LOOP",
	"ACT_180_LEFT",
	"ACT_180_RIGHT",
	"ACT_90_LEFT",
	"ACT_90_RIGHT",
	"ACT_STEP_LEFT",
	"ACT_STEP_RIGHT",
	"ACT_STEP_BACK",
	"ACT_STEP_FORE",
	"ACT_GESTURE_RANGE_ATTACK1",
	"ACT_GESTURE_RANGE_ATTACK2",
	"ACT_GESTURE_MELEE_ATTACK1",
	"ACT_GESTURE_MELEE_ATTACK2",
	"ACT_GESTURE_RANGE_ATTACK1_LOW",
	"ACT_GESTURE_RANGE_ATTACK2_LOW",
	"ACT_MELEE_ATTACK_SWING_GESTURE",
	"ACT_GESTURE_SMALL_FLINCH",
	"ACT_GESTURE_BIG_FLINCH",
	"ACT_GESTURE_FLINCH_BLAST",
	"ACT_GESTURE_FLINCH_BLAST_SHOTGUN",
	"ACT_GESTURE_FLINCH_BLAST_DAMAGED",
	"ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN",
	"ACT_GESTURE_FLINCH_HEAD",
	"ACT_GESTURE_FLINCH_CHEST",
	"ACT_GESTURE_FLINCH_STOMACH",
	"ACT_GESTURE_FLINCH_LEFTARM",
	"ACT_GESTURE_FLINCH_RIGHTARM",
	"ACT_GESTURE_FLINCH_LEFTLEG",
	"ACT_GESTURE_FLINCH_RIGHTLEG",
	"ACT_GESTURE_TURN_LEFT",
	"ACT_GESTURE_TURN_RIGHT",
	"ACT_GESTURE_TURN_LEFT45",
	"ACT_GESTURE_TURN_RIGHT45",
	"ACT_GESTURE_TURN_LEFT90",
	"ACT_GESTURE_TURN_RIGHT90",
	"ACT_GESTURE_TURN_LEFT45_FLAT",
	"ACT_GESTURE_TURN_RIGHT45_FLAT",
	"ACT_GESTURE_TURN_LEFT90_FLAT",
	"ACT_GESTURE_TURN_RIGHT90_FLAT",
	"ACT_BARNACLE_HIT",
	"ACT_BARNACLE_PULL",
	"ACT_BARNACLE_CHOMP",
	"ACT_BARNACLE_CHEW",
	"ACT_DO_NOT_DISTURB",
	"ACT_VM_DRAW",
	"ACT_VM_INSPECT",
	"ACT_VM_INSPECT_SILENCED",
	"ACT_VM_DRAW_INSPECT",
	"ACT_VM_DRAW_INSPECT_SILENCED",
	"ACT_VM_INSPECT1",
	"ACT_VM_INSPECT2",
	"ACT_VM_INSPECT3",
	"ACT_VM_ADMIRE",
	"ACT_VM_ADMIRE1",
	"ACT_VM_ADMIRE2",
	"ACT_VM_ADMIRE3",
	"ACT_VM_HOLSTER",
	"ACT_VM_IDLE",
	"ACT_VM_FIDGET",
	"ACT_VM_PULLBACK",
	"ACT_VM_PULLBACK_HIGH",
	"ACT_VM_PULLBACK_LOW",
	"ACT_VM_THROW",
	"ACT_VM_PULLPIN",
	"ACT_VM_PRIMARYATTACK",
	"ACT_VM_SECONDARYATTACK",
	"ACT_VM_RELOAD",
	"ACT_VM_EMPTY_RELOAD",
	"ACT_VM_EMPTY_FIRE",
	"ACT_VM_RELOAD_START",
	"ACT_VM_RELOAD_FINISH",
	"ACT_VM_DRYFIRE",
	"ACT_VM_HITLEFT",
	"ACT_VM_HITLEFT2",
	"ACT_VM_HITRIGHT",
	"ACT_VM_HITRIGHT2",
	"ACT_VM_HITCENTER",
	"ACT_VM_HITCENTER2",
	"ACT_VM_MISSLEFT",
	"ACT_VM_MISSLEFT2",
	"ACT_VM_MISSRIGHT",
	"ACT_VM_MISSRIGHT2",
	"ACT_VM_MISSCENTER",
	"ACT_VM_MISSCENTER2",
	"ACT_VM_HAULBACK",
	"ACT_VM_SWINGHARD",
	"ACT_VM_SWINGMISS",
	"ACT_VM_SWINGHIT",
	"ACT_VM_IDLE_TO_LOWERED",
	"ACT_VM_IDLE_LOWERED",
	"ACT_VM_SPRINT",
	"ACT_VM_WALL",
	"ACT_VM_WALK",
	"ACT_VM_LOWERED_TO_IDLE",
	"ACT_VM_RECOIL1",
	"ACT_VM_RECOIL2",
	"ACT_VM_RECOIL3",
	"ACT_VM_PICKUP",
	"ACT_VM_RELEASE",
	"ACT_VM_MELEE",
	"ACT_VM_HOLSTER_SILENCED",
	"ACT_VM_ATTACH_SILENCER",
	"ACT_VM_DETACH_SILENCER",
	"ACT_VM_DRAW_SPECIAL",
	"ACT_VM_HOLSTER_SPECIAL",
	"ACT_VM_IDLE_SPECIAL",
	"ACT_VM_PULLBACK_SPECIAL",
	"ACT_VM_PRIMARYATTACK_SPECIAL",
	"ACT_VM_SECONDARYATTACK_SPECIAL",
	"ACT_VM_HITCENTER_SPECIAL",
	"ACT_VM_SWINGHARD_SPECIAL",
	"ACT_VM_IDLE_TO_LOWERED_SPECIAL",
	"ACT_VM_IDLE_LOWERED_SPECIAL",
	"ACT_VM_LOWERED_TO_IDLE_SPECIAL",
	"ACT_VM_FIREMODE",
	"ACT_VM_SWITCHMODE",
	"ACT_FISTS_VM_HITLEFT",
	"ACT_FISTS_VM_HITRIGHT",
	"ACT_FISTS_VM_SWINGHARD",
	"ACT_FISTS_VM_IDLE",
	"ACT_FISTS_VM_DRAW",
	"ACT_SLAM_STICKWALL_IDLE",
	"ACT_SLAM_STICKWALL_ND_IDLE",
	"ACT_SLAM_STICKWALL_ATTACH",
	"ACT_SLAM_STICKWALL_ATTACH2",
	"ACT_SLAM_STICKWALL_ND_ATTACH",
	"ACT_SLAM_STICKWALL_ND_ATTACH2",
	"ACT_SLAM_STICKWALL_DETONATE",
	"ACT_SLAM_STICKWALL_DETONATOR_HOLSTER",
	"ACT_SLAM_STICKWALL_DRAW",
	"ACT_SLAM_STICKWALL_ND_DRAW",
	"ACT_SLAM_STICKWALL_TO_THROW",
	"ACT_SLAM_STICKWALL_TO_THROW_ND",
	"ACT_SLAM_STICKWALL_TO_TRIPMINE_ND",
	"ACT_SLAM_THROW_IDLE",
	"ACT_SLAM_THROW_ND_IDLE",
	"ACT_SLAM_THROW_THROW",
	"ACT_SLAM_THROW_THROW2",
	"ACT_SLAM_THROW_THROW_ND",
	"ACT_SLAM_THROW_THROW_ND2",
	"ACT_SLAM_THROW_DRAW",
	"ACT_SLAM_THROW_ND_DRAW",
	"ACT_SLAM_THROW_TO_STICKWALL",
	"ACT_SLAM_THROW_TO_STICKWALL_ND",
	"ACT_SLAM_THROW_DETONATE",
	"ACT_SLAM_THROW_DETONATOR_HOLSTER",
	"ACT_SLAM_THROW_TO_TRIPMINE_ND",
	"ACT_SLAM_TRIPMINE_IDLE",
	"ACT_SLAM_TRIPMINE_DRAW",
	"ACT_SLAM_TRIPMINE_ATTACH",
	"ACT_SLAM_TRIPMINE_ATTACH2",
	"ACT_SLAM_TRIPMINE_TO_STICKWALL_ND",
	"ACT_SLAM_TRIPMINE_TO_THROW_ND",
	"ACT_SLAM_DETONATOR_IDLE",
	"ACT_SLAM_DETONATOR_DRAW",
	"ACT_SLAM_DETONATOR_DETONATE",
	"ACT_SLAM_DETONATOR_HOLSTER",
	"ACT_SLAM_DETONATOR_STICKWALL_DRAW",
	"ACT_SLAM_DETONATOR_THROW_DRAW",
	"ACT_SHOTGUN_RELOAD_START",
	"ACT_SHOTGUN_RELOAD_FINISH",
	"ACT_SHOTGUN_PUMP",
	"ACT_SHOTGUN_PUMP2",
	"ACT_SHOTGUN_PUMP_DOUBLE",
	"ACT_SHOTGUN_PUMP2_DOUBLE",
	"ACT_SMG2_IDLE2",
	"ACT_SMG2_FIRE2",
	"ACT_SMG2_DRAW2",
	"ACT_SMG2_RELOAD2",
	"ACT_SMG2_DRYFIRE2",
	"ACT_SMG2_TOAUTO",
	"ACT_SMG2_TOBURST",
	"ACT_PHYSCANNON_UPGRADE",
	"ACT_RANGE_ATTACK_AR1",
	"ACT_RANGE_ATTACK_AR2",
	"ACT_RANGE_ATTACK_AR2_LOW",
	"ACT_RANGE_ATTACK_AR2_GRENADE",
	"ACT_RANGE_ATTACK_HMG1",
	"ACT_RANGE_ATTACK_ML",
	"ACT_RANGE_ATTACK_SMG1",
	"ACT_RANGE_ATTACK_SMG1_LOW",
	"ACT_RANGE_ATTACK_SMG2",
	"ACT_RANGE_ATTACK_SHOTGUN",
	"ACT_RANGE_ATTACK_SHOTGUN_LOW",
	"ACT_RANGE_ATTACK_PISTOL",
	"ACT_RANGE_ATTACK_PISTOL_LOW",
	"ACT_RANGE_ATTACK_SLAM",
	"ACT_RANGE_ATTACK_TRIPWIRE",
	"ACT_RANGE_ATTACK_THROW",
	"ACT_RANGE_ATTACK_SNIPER_RIFLE",
	"ACT_RANGE_ATTACK_RPG",
	"ACT_MELEE_ATTACK_SWING",
	"ACT_RANGE_AIM_LOW",
	"ACT_RANGE_AIM_SMG1_LOW",
	"ACT_RANGE_AIM_PISTOL_LOW",
	"ACT_RANGE_AIM_AR2_LOW",
	"ACT_COVER_PISTOL_LOW",
	"ACT_COVER_SMG1_LOW",
	"ACT_GESTURE_RANGE_ATTACK_AR1",
	"ACT_GESTURE_RANGE_ATTACK_AR2",
	"ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE",
	"ACT_GESTURE_RANGE_ATTACK_HMG1",
	"ACT_GESTURE_RANGE_ATTACK_ML",
	"ACT_GESTURE_RANGE_ATTACK_SMG1",
	"ACT_GESTURE_RANGE_ATTACK_SMG1_LOW",
	"ACT_GESTURE_RANGE_ATTACK_SMG2",
	"ACT_GESTURE_RANGE_ATTACK_SHOTGUN",
	"ACT_GESTURE_RANGE_ATTACK_PISTOL",
	"ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW",
	"ACT_GESTURE_RANGE_ATTACK_SLAM",
	"ACT_GESTURE_RANGE_ATTACK_TRIPWIRE",
	"ACT_GESTURE_RANGE_ATTACK_THROW",
	"ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE",
	"ACT_GESTURE_MELEE_ATTACK_SWING",
	"ACT_IDLE_RIFLE",
	"ACT_IDLE_SMG1",
	"ACT_IDLE_ANGRY_SMG1",
	"ACT_IDLE_PISTOL",
	"ACT_IDLE_ANGRY_PISTOL",
	"ACT_IDLE_ANGRY_SHOTGUN",
	"ACT_IDLE_STEALTH_PISTOL",
	"ACT_IDLE_PACKAGE",
	"ACT_WALK_PACKAGE",
	"ACT_IDLE_SUITCASE",
	"ACT_WALK_SUITCASE",
	"ACT_IDLE_SMG1_RELAXED",
	"ACT_IDLE_SMG1_STIMULATED",
	"ACT_WALK_RIFLE_RELAXED",
	"ACT_RUN_RIFLE_RELAXED",
	"ACT_WALK_RIFLE_STIMULATED",
	"ACT_RUN_RIFLE_STIMULATED",
	"ACT_IDLE_AIM_RIFLE_STIMULATED",
	"ACT_WALK_AIM_RIFLE_STIMULATED",
	"ACT_RUN_AIM_RIFLE_STIMULATED",
	"ACT_IDLE_SHOTGUN_RELAXED",
	"ACT_IDLE_SHOTGUN_STIMULATED",
	"ACT_IDLE_SHOTGUN_AGITATED",
	"ACT_WALK_ANGRY",
	"ACT_POLICE_HARASS1",
	"ACT_POLICE_HARASS2",
	"ACT_IDLE_MANNEDGUN",
	"ACT_IDLE_MELEE",
	"ACT_IDLE_ANGRY_MELEE",
	"ACT_IDLE_RPG_RELAXED",
	"ACT_IDLE_RPG",
	"ACT_IDLE_ANGRY_RPG",
	"ACT_COVER_LOW_RPG",
	"ACT_WALK_RPG",
	"ACT_RUN_RPG",
	"ACT_WALK_CROUCH_RPG",
	"ACT_RUN_CROUCH_RPG",
	"ACT_WALK_RPG_RELAXED",
	"ACT_RUN_RPG_RELAXED",
	"ACT_WALK_RIFLE",
	"ACT_WALK_AIM_RIFLE",
	"ACT_WALK_CROUCH_RIFLE",
	"ACT_WALK_CROUCH_AIM_RIFLE",
	"ACT_RUN_RIFLE",
	"ACT_RUN_AIM_RIFLE",
	"ACT_RUN_CROUCH_RIFLE",
	"ACT_RUN_CROUCH_AIM_RIFLE",
	"ACT_RUN_STEALTH_PISTOL",
	"ACT_WALK_AIM_SHOTGUN",
	"ACT_RUN_AIM_SHOTGUN",
	"ACT_WALK_PISTOL",
	"ACT_RUN_PISTOL",
	"ACT_WALK_AIM_PISTOL",
	"ACT_RUN_AIM_PISTOL",
	"ACT_WALK_STEALTH_PISTOL",
	"ACT_WALK_AIM_STEALTH_PISTOL",
	"ACT_RUN_AIM_STEALTH_PISTOL",
	"ACT_RELOAD_PISTOL",
	"ACT_RELOAD_PISTOL_LOW",
	"ACT_RELOAD_SMG1",
	"ACT_RELOAD_SMG1_LOW",
	"ACT_RELOAD_SHOTGUN",
	"ACT_RELOAD_SHOTGUN_LOW",
	"ACT_GESTURE_RELOAD",
	"ACT_GESTURE_RELOAD_PISTOL",
	"ACT_GESTURE_RELOAD_SMG1",
	"ACT_GESTURE_RELOAD_SHOTGUN",
	"ACT_BUSY_LEAN_LEFT",
	"ACT_BUSY_LEAN_LEFT_ENTRY",
	"ACT_BUSY_LEAN_LEFT_EXIT",
	"ACT_BUSY_LEAN_BACK",
	"ACT_BUSY_LEAN_BACK_ENTRY",
	"ACT_BUSY_LEAN_BACK_EXIT",
	"ACT_BUSY_SIT_GROUND",
	"ACT_BUSY_SIT_GROUND_ENTRY",
	"ACT_BUSY_SIT_GROUND_EXIT",
	"ACT_BUSY_SIT_CHAIR",
	"ACT_BUSY_SIT_CHAIR_ENTRY",
	"ACT_BUSY_SIT_CHAIR_EXIT",
	"ACT_BUSY_STAND",
	"ACT_BUSY_QUEUE",
	"ACT_DUCK_DODGE",
	"ACT_DIE_BARNACLE_SWALLOW",
	"ACT_GESTURE_BARNACLE_STRANGLE",
	"ACT_PHYSCANNON_DETACH",
	"ACT_PHYSCANNON_ANIMATE",
	"ACT_PHYSCANNON_ANIMATE_PRE",
	"ACT_PHYSCANNON_ANIMATE_POST",
	"ACT_DIE_FRONTSIDE",
	"ACT_DIE_RIGHTSIDE",
	"ACT_DIE_BACKSIDE",
	"ACT_DIE_LEFTSIDE",
	"ACT_OPEN_DOOR",
	"ACT_DI_ALYX_ZOMBIE_MELEE",
	"ACT_DI_ALYX_ZOMBIE_TORSO_MELEE",
	"ACT_DI_ALYX_HEADCRAB_MELEE",
	"ACT_DI_ALYX_ANTLION",
	"ACT_DI_ALYX_ZOMBIE_SHOTGUN64",
	"ACT_DI_ALYX_ZOMBIE_SHOTGUN26",
	"ACT_READINESS_RELAXED_TO_STIMULATED",
	"ACT_READINESS_RELAXED_TO_STIMULATED_WALK",
	"ACT_READINESS_AGITATED_TO_STIMULATED",
	"ACT_READINESS_STIMULATED_TO_RELAXED",
	"ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED",
	"ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK",
	"ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED",
	"ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED",
	"ACT_IDLE_CARRY",
	"ACT_WALK_CARRY",
	"ACT_STARTDYING",
	"ACT_DYINGLOOP",
	"ACT_DYINGTODEAD",
	"ACT_RIDE_MANNED_GUN",
	"ACT_VM_SPRINT_ENTER",
	"ACT_VM_SPRINT_IDLE",
	"ACT_VM_SPRINT_LEAVE",
	"ACT_FIRE_START",
	"ACT_FIRE_LOOP",
	"ACT_FIRE_END",
	"ACT_CROUCHING_GRENADEIDLE",
	"ACT_CROUCHING_GRENADEREADY",
	"ACT_CROUCHING_PRIMARYATTACK",
	"ACT_OVERLAY_GRENADEIDLE",
	"ACT_OVERLAY_GRENADEREADY",
	"ACT_OVERLAY_PRIMARYATTACK",
	"ACT_OVERLAY_SHIELD_UP",
	"ACT_OVERLAY_SHIELD_DOWN",
	"ACT_OVERLAY_SHIELD_UP_IDLE",
	"ACT_OVERLAY_SHIELD_ATTACK",
	"ACT_OVERLAY_SHIELD_KNOCKBACK",
	"ACT_SHIELD_UP",
	"ACT_SHIELD_DOWN",
	"ACT_SHIELD_UP_IDLE",
	"ACT_SHIELD_ATTACK",
	"ACT_SHIELD_KNOCKBACK",
	"ACT_CROUCHING_SHIELD_UP",
	"ACT_CROUCHING_SHIELD_DOWN",
	"ACT_CROUCHING_SHIELD_UP_IDLE",
	"ACT_CROUCHING_SHIELD_ATTACK",
	"ACT_CROUCHING_SHIELD_KNOCKBACK",
	"ACT_TURNRIGHT45",
	"ACT_TURNLEFT45",
	"ACT_TURN",
	"ACT_OBJ_ASSEMBLING",
	"ACT_OBJ_DISMANTLING",
	"ACT_OBJ_STARTUP",
	"ACT_OBJ_RUNNING",
	"ACT_OBJ_IDLE",
	"ACT_OBJ_PLACING",
	"ACT_OBJ_DETERIORATING",
	"ACT_OBJ_UPGRADING",
	"ACT_DEPLOY",
	"ACT_DEPLOY_IDLE",
	"ACT_UNDEPLOY",
	"ACT_GRENADE_ROLL",
	"ACT_GRENADE_TOSS",
	"ACT_HANDGRENADE_THROW1",
	"ACT_HANDGRENADE_THROW2",
	"ACT_HANDGRENADE_THROW3",
	"ACT_SHOTGUN_IDLE_DEEP",
	"ACT_SHOTGUN_IDLE4",
	"ACT_GLOCK_SHOOTEMPTY",
	"ACT_GLOCK_SHOOT_RELOAD",
	"ACT_RPG_DRAW_UNLOADED",
	"ACT_RPG_HOLSTER_UNLOADED",
	"ACT_RPG_IDLE_UNLOADED",
	"ACT_RPG_FIDGET_UNLOADED",
	"ACT_CROSSBOW_DRAW_UNLOADED",
	"ACT_CROSSBOW_IDLE_UNLOADED",
	"ACT_CROSSBOW_FIDGET_UNLOADED",
	"ACT_GAUSS_SPINUP",
	"ACT_GAUSS_SPINCYCLE",
	"ACT_TRIPMINE_GROUND",
	"ACT_TRIPMINE_WORLD",
	"ACT_VM_PRIMARYATTACK_SILENCED",
	"ACT_VM_RELOAD_SILENCED",
	"ACT_VM_DRYFIRE_SILENCED",
	"ACT_VM_IDLE_SILENCED",
	"ACT_VM_DRAW_SILENCED",
	"ACT_VM_IDLE_EMPTY_LEFT",
	"ACT_VM_DRYFIRE_LEFT",
	"ACT_VM_PRIMARYATTACK_IRONSIGHTED1",
	"ACT_VM_PRIMARYATTACK_IRONSIGHTED2",
	"ACT_VM_PRIMARYATTACK_IRONSIGHTED3",
	"ACT_PLAYER_IDLE_FIRE",
	"ACT_PLAYER_CROUCH_FIRE",
	"ACT_PLAYER_CROUCH_WALK_FIRE",
	"ACT_PLAYER_WALK_FIRE",
	"ACT_PLAYER_RUN_FIRE",
	"ACT_IDLETORUN",
	"ACT_RUNTOIDLE",
	"ACT_SPRINT",
	"ACT_GET_DOWN_STAND",
	"ACT_GET_UP_STAND",
	"ACT_GET_DOWN_CROUCH",
	"ACT_GET_UP_CROUCH",
	"ACT_PRONE_FORWARD",
	"ACT_PRONE_IDLE",
	"ACT_DEEPIDLE1",
	"ACT_DEEPIDLE2",
	"ACT_DEEPIDLE3",
	"ACT_DEEPIDLE4",
	"ACT_VM_RELOAD_DEPLOYED",
	"ACT_VM_RELOAD_IDLE",
	"ACT_VM_DRAW_DEPLOYED",
	"ACT_VM_DRAW_EMPTY",
	"ACT_VM_PRIMARYATTACK_EMPTY",
	"ACT_VM_RELOAD_EMPTY",
	"ACT_VM_IDLE_EMPTY",
	"ACT_VM_IDLE_DEPLOYED_EMPTY",
	"ACT_VM_IDLE_8",
	"ACT_VM_IDLE_7",
	"ACT_VM_IDLE_6",
	"ACT_VM_IDLE_5",
	"ACT_VM_IDLE_4",
	"ACT_VM_IDLE_3",
	"ACT_VM_IDLE_2",
	"ACT_VM_IDLE_1",
	"ACT_VM_IDLE_DEPLOYED",
	"ACT_VM_IDLE_DEPLOYED_8",
	"ACT_VM_IDLE_DEPLOYED_7",
	"ACT_VM_IDLE_DEPLOYED_6",
	"ACT_VM_IDLE_DEPLOYED_5",
	"ACT_VM_IDLE_DEPLOYED_4",
	"ACT_VM_IDLE_DEPLOYED_3",
	"ACT_VM_IDLE_DEPLOYED_2",
	"ACT_VM_IDLE_DEPLOYED_1",
	"ACT_VM_UNDEPLOY",
	"ACT_VM_UNDEPLOY_8",
	"ACT_VM_UNDEPLOY_7",
	"ACT_VM_UNDEPLOY_6",
	"ACT_VM_UNDEPLOY_5",
	"ACT_VM_UNDEPLOY_4",
	"ACT_VM_UNDEPLOY_3",
	"ACT_VM_UNDEPLOY_2",
	"ACT_VM_UNDEPLOY_1",
	"ACT_VM_UNDEPLOY_EMPTY",
	"ACT_VM_DEPLOY",
	"ACT_VM_DEPLOY_8",
	"ACT_VM_DEPLOY_7",
	"ACT_VM_DEPLOY_6",
	"ACT_VM_DEPLOY_5",
	"ACT_VM_DEPLOY_4",
	"ACT_VM_DEPLOY_3",
	"ACT_VM_DEPLOY_2",
	"ACT_VM_DEPLOY_1",
	"ACT_VM_DEPLOY_EMPTY",
	"ACT_VM_PRIMARYATTACK_8",
	"ACT_VM_PRIMARYATTACK_7",
	"ACT_VM_PRIMARYATTACK_6",
	"ACT_VM_PRIMARYATTACK_5",
	"ACT_VM_PRIMARYATTACK_4",
	"ACT_VM_PRIMARYATTACK_3",
	"ACT_VM_PRIMARYATTACK_2",
	"ACT_VM_PRIMARYATTACK_1",
	"ACT_VM_PRIMARYATTACK_DEPLOYED",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_8",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_7",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_6",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_5",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_4",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_3",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_2",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_1",
	"ACT_VM_PRIMARYATTACK_DEPLOYED_EMPTY",
	"ACT_DOD_DEPLOYED",
	"ACT_DOD_PRONE_DEPLOYED",
	"ACT_DOD_IDLE_ZOOMED",
	"ACT_DOD_WALK_ZOOMED",
	"ACT_DOD_CROUCH_ZOOMED",
	"ACT_DOD_CROUCHWALK_ZOOMED",
	"ACT_DOD_PRONE_ZOOMED",
	"ACT_DOD_PRONE_FORWARD_ZOOMED",
	"ACT_DOD_PRIMARYATTACK_DEPLOYED",
	"ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED",
	"ACT_DOD_RELOAD_DEPLOYED",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED",
	"ACT_DOD_PRIMARYATTACK_PRONE",
	"ACT_DOD_SECONDARYATTACK_PRONE",
	"ACT_DOD_RELOAD_CROUCH",
	"ACT_DOD_RELOAD_PRONE",
	"ACT_DOD_STAND_IDLE",
	"ACT_DOD_STAND_AIM",
	"ACT_DOD_CROUCH_IDLE",
	"ACT_DOD_CROUCH_AIM",
	"ACT_DOD_CROUCHWALK_IDLE",
	"ACT_DOD_CROUCHWALK_AIM",
	"ACT_DOD_WALK_IDLE",
	"ACT_DOD_WALK_AIM",
	"ACT_DOD_RUN_IDLE",
	"ACT_DOD_RUN_AIM",
	"ACT_DOD_STAND_AIM_PISTOL",
	"ACT_DOD_CROUCH_AIM_PISTOL",
	"ACT_DOD_CROUCHWALK_AIM_PISTOL",
	"ACT_DOD_WALK_AIM_PISTOL",
	"ACT_DOD_RUN_AIM_PISTOL",
	"ACT_DOD_PRONE_AIM_PISTOL",
	"ACT_DOD_STAND_IDLE_PISTOL",
	"ACT_DOD_CROUCH_IDLE_PISTOL",
	"ACT_DOD_CROUCHWALK_IDLE_PISTOL",
	"ACT_DOD_WALK_IDLE_PISTOL",
	"ACT_DOD_RUN_IDLE_PISTOL",
	"ACT_DOD_SPRINT_IDLE_PISTOL",
	"ACT_DOD_PRONEWALK_IDLE_PISTOL",
	"ACT_DOD_STAND_AIM_C96",
	"ACT_DOD_CROUCH_AIM_C96",
	"ACT_DOD_CROUCHWALK_AIM_C96",
	"ACT_DOD_WALK_AIM_C96",
	"ACT_DOD_RUN_AIM_C96",
	"ACT_DOD_PRONE_AIM_C96",
	"ACT_DOD_STAND_IDLE_C96",
	"ACT_DOD_CROUCH_IDLE_C96",
	"ACT_DOD_CROUCHWALK_IDLE_C96",
	"ACT_DOD_WALK_IDLE_C96",
	"ACT_DOD_RUN_IDLE_C96",
	"ACT_DOD_SPRINT_IDLE_C96",
	"ACT_DOD_PRONEWALK_IDLE_C96",
	"ACT_DOD_STAND_AIM_RIFLE",
	"ACT_DOD_CROUCH_AIM_RIFLE",
	"ACT_DOD_CROUCHWALK_AIM_RIFLE",
	"ACT_DOD_WALK_AIM_RIFLE",
	"ACT_DOD_RUN_AIM_RIFLE",
	"ACT_DOD_PRONE_AIM_RIFLE",
	"ACT_DOD_STAND_IDLE_RIFLE",
	"ACT_DOD_CROUCH_IDLE_RIFLE",
	"ACT_DOD_CROUCHWALK_IDLE_RIFLE",
	"ACT_DOD_WALK_IDLE_RIFLE",
	"ACT_DOD_RUN_IDLE_RIFLE",
	"ACT_DOD_SPRINT_IDLE_RIFLE",
	"ACT_DOD_PRONEWALK_IDLE_RIFLE",
	"ACT_DOD_STAND_AIM_BOLT",
	"ACT_DOD_CROUCH_AIM_BOLT",
	"ACT_DOD_CROUCHWALK_AIM_BOLT",
	"ACT_DOD_WALK_AIM_BOLT",
	"ACT_DOD_RUN_AIM_BOLT",
	"ACT_DOD_PRONE_AIM_BOLT",
	"ACT_DOD_STAND_IDLE_BOLT",
	"ACT_DOD_CROUCH_IDLE_BOLT",
	"ACT_DOD_CROUCHWALK_IDLE_BOLT",
	"ACT_DOD_WALK_IDLE_BOLT",
	"ACT_DOD_RUN_IDLE_BOLT",
	"ACT_DOD_SPRINT_IDLE_BOLT",
	"ACT_DOD_PRONEWALK_IDLE_BOLT",
	"ACT_DOD_STAND_AIM_TOMMY",
	"ACT_DOD_CROUCH_AIM_TOMMY",
	"ACT_DOD_CROUCHWALK_AIM_TOMMY",
	"ACT_DOD_WALK_AIM_TOMMY",
	"ACT_DOD_RUN_AIM_TOMMY",
	"ACT_DOD_PRONE_AIM_TOMMY",
	"ACT_DOD_STAND_IDLE_TOMMY",
	"ACT_DOD_CROUCH_IDLE_TOMMY",
	"ACT_DOD_CROUCHWALK_IDLE_TOMMY",
	"ACT_DOD_WALK_IDLE_TOMMY",
	"ACT_DOD_RUN_IDLE_TOMMY",
	"ACT_DOD_SPRINT_IDLE_TOMMY",
	"ACT_DOD_PRONEWALK_IDLE_TOMMY",
	"ACT_DOD_STAND_AIM_MP40",
	"ACT_DOD_CROUCH_AIM_MP40",
	"ACT_DOD_CROUCHWALK_AIM_MP40",
	"ACT_DOD_WALK_AIM_MP40",
	"ACT_DOD_RUN_AIM_MP40",
	"ACT_DOD_PRONE_AIM_MP40",
	"ACT_DOD_STAND_IDLE_MP40",
	"ACT_DOD_CROUCH_IDLE_MP40",
	"ACT_DOD_CROUCHWALK_IDLE_MP40",
	"ACT_DOD_WALK_IDLE_MP40",
	"ACT_DOD_RUN_IDLE_MP40",
	"ACT_DOD_SPRINT_IDLE_MP40",
	"ACT_DOD_PRONEWALK_IDLE_MP40",
	"ACT_DOD_STAND_AIM_MP44",
	"ACT_DOD_CROUCH_AIM_MP44",
	"ACT_DOD_CROUCHWALK_AIM_MP44",
	"ACT_DOD_WALK_AIM_MP44",
	"ACT_DOD_RUN_AIM_MP44",
	"ACT_DOD_PRONE_AIM_MP44",
	"ACT_DOD_STAND_IDLE_MP44",
	"ACT_DOD_CROUCH_IDLE_MP44",
	"ACT_DOD_CROUCHWALK_IDLE_MP44",
	"ACT_DOD_WALK_IDLE_MP44",
	"ACT_DOD_RUN_IDLE_MP44",
	"ACT_DOD_SPRINT_IDLE_MP44",
	"ACT_DOD_PRONEWALK_IDLE_MP44",
	"ACT_DOD_STAND_AIM_GREASE",
	"ACT_DOD_CROUCH_AIM_GREASE",
	"ACT_DOD_CROUCHWALK_AIM_GREASE",
	"ACT_DOD_WALK_AIM_GREASE",
	"ACT_DOD_RUN_AIM_GREASE",
	"ACT_DOD_PRONE_AIM_GREASE",
	"ACT_DOD_STAND_IDLE_GREASE",
	"ACT_DOD_CROUCH_IDLE_GREASE",
	"ACT_DOD_CROUCHWALK_IDLE_GREASE",
	"ACT_DOD_WALK_IDLE_GREASE",
	"ACT_DOD_RUN_IDLE_GREASE",
	"ACT_DOD_SPRINT_IDLE_GREASE",
	"ACT_DOD_PRONEWALK_IDLE_GREASE",
	"ACT_DOD_STAND_AIM_MG",
	"ACT_DOD_CROUCH_AIM_MG",
	"ACT_DOD_CROUCHWALK_AIM_MG",
	"ACT_DOD_WALK_AIM_MG",
	"ACT_DOD_RUN_AIM_MG",
	"ACT_DOD_PRONE_AIM_MG",
	"ACT_DOD_STAND_IDLE_MG",
	"ACT_DOD_CROUCH_IDLE_MG",
	"ACT_DOD_CROUCHWALK_IDLE_MG",
	"ACT_DOD_WALK_IDLE_MG",
	"ACT_DOD_RUN_IDLE_MG",
	"ACT_DOD_SPRINT_IDLE_MG",
	"ACT_DOD_PRONEWALK_IDLE_MG",
	"ACT_DOD_STAND_AIM_30CAL",
	"ACT_DOD_CROUCH_AIM_30CAL",
	"ACT_DOD_CROUCHWALK_AIM_30CAL",
	"ACT_DOD_WALK_AIM_30CAL",
	"ACT_DOD_RUN_AIM_30CAL",
	"ACT_DOD_PRONE_AIM_30CAL",
	"ACT_DOD_STAND_IDLE_30CAL",
	"ACT_DOD_CROUCH_IDLE_30CAL",
	"ACT_DOD_CROUCHWALK_IDLE_30CAL",
	"ACT_DOD_WALK_IDLE_30CAL",
	"ACT_DOD_RUN_IDLE_30CAL",
	"ACT_DOD_SPRINT_IDLE_30CAL",
	"ACT_DOD_PRONEWALK_IDLE_30CAL",
	"ACT_DOD_STAND_AIM_GREN_FRAG",
	"ACT_DOD_CROUCH_AIM_GREN_FRAG",
	"ACT_DOD_CROUCHWALK_AIM_GREN_FRAG",
	"ACT_DOD_WALK_AIM_GREN_FRAG",
	"ACT_DOD_RUN_AIM_GREN_FRAG",
	"ACT_DOD_PRONE_AIM_GREN_FRAG",
	"ACT_DOD_SPRINT_AIM_GREN_FRAG",
	"ACT_DOD_PRONEWALK_AIM_GREN_FRAG",
	"ACT_DOD_STAND_AIM_GREN_STICK",
	"ACT_DOD_CROUCH_AIM_GREN_STICK",
	"ACT_DOD_CROUCHWALK_AIM_GREN_STICK",
	"ACT_DOD_WALK_AIM_GREN_STICK",
	"ACT_DOD_RUN_AIM_GREN_STICK",
	"ACT_DOD_PRONE_AIM_GREN_STICK",
	"ACT_DOD_SPRINT_AIM_GREN_STICK",
	"ACT_DOD_PRONEWALK_AIM_GREN_STICK",
	"ACT_DOD_STAND_AIM_KNIFE",
	"ACT_DOD_CROUCH_AIM_KNIFE",
	"ACT_DOD_CROUCHWALK_AIM_KNIFE",
	"ACT_DOD_WALK_AIM_KNIFE",
	"ACT_DOD_RUN_AIM_KNIFE",
	"ACT_DOD_PRONE_AIM_KNIFE",
	"ACT_DOD_SPRINT_AIM_KNIFE",
	"ACT_DOD_PRONEWALK_AIM_KNIFE",
	"ACT_DOD_STAND_AIM_SPADE",
	"ACT_DOD_CROUCH_AIM_SPADE",
	"ACT_DOD_CROUCHWALK_AIM_SPADE",
	"ACT_DOD_WALK_AIM_SPADE",
	"ACT_DOD_RUN_AIM_SPADE",
	"ACT_DOD_PRONE_AIM_SPADE",
	"ACT_DOD_SPRINT_AIM_SPADE",
	"ACT_DOD_PRONEWALK_AIM_SPADE",
	"ACT_DOD_STAND_AIM_BAZOOKA",
	"ACT_DOD_CROUCH_AIM_BAZOOKA",
	"ACT_DOD_CROUCHWALK_AIM_BAZOOKA",
	"ACT_DOD_WALK_AIM_BAZOOKA",
	"ACT_DOD_RUN_AIM_BAZOOKA",
	"ACT_DOD_PRONE_AIM_BAZOOKA",
	"ACT_DOD_STAND_IDLE_BAZOOKA",
	"ACT_DOD_CROUCH_IDLE_BAZOOKA",
	"ACT_DOD_CROUCHWALK_IDLE_BAZOOKA",
	"ACT_DOD_WALK_IDLE_BAZOOKA",
	"ACT_DOD_RUN_IDLE_BAZOOKA",
	"ACT_DOD_SPRINT_IDLE_BAZOOKA",
	"ACT_DOD_PRONEWALK_IDLE_BAZOOKA",
	"ACT_DOD_STAND_AIM_PSCHRECK",
	"ACT_DOD_CROUCH_AIM_PSCHRECK",
	"ACT_DOD_CROUCHWALK_AIM_PSCHRECK",
	"ACT_DOD_WALK_AIM_PSCHRECK",
	"ACT_DOD_RUN_AIM_PSCHRECK",
	"ACT_DOD_PRONE_AIM_PSCHRECK",
	"ACT_DOD_STAND_IDLE_PSCHRECK",
	"ACT_DOD_CROUCH_IDLE_PSCHRECK",
	"ACT_DOD_CROUCHWALK_IDLE_PSCHRECK",
	"ACT_DOD_WALK_IDLE_PSCHRECK",
	"ACT_DOD_RUN_IDLE_PSCHRECK",
	"ACT_DOD_SPRINT_IDLE_PSCHRECK",
	"ACT_DOD_PRONEWALK_IDLE_PSCHRECK",
	"ACT_DOD_STAND_AIM_BAR",
	"ACT_DOD_CROUCH_AIM_BAR",
	"ACT_DOD_CROUCHWALK_AIM_BAR",
	"ACT_DOD_WALK_AIM_BAR",
	"ACT_DOD_RUN_AIM_BAR",
	"ACT_DOD_PRONE_AIM_BAR",
	"ACT_DOD_STAND_IDLE_BAR",
	"ACT_DOD_CROUCH_IDLE_BAR",
	"ACT_DOD_CROUCHWALK_IDLE_BAR",
	"ACT_DOD_WALK_IDLE_BAR",
	"ACT_DOD_RUN_IDLE_BAR",
	"ACT_DOD_SPRINT_IDLE_BAR",
	"ACT_DOD_PRONEWALK_IDLE_BAR",
	"ACT_DOD_STAND_ZOOM_RIFLE",
	"ACT_DOD_CROUCH_ZOOM_RIFLE",
	"ACT_DOD_CROUCHWALK_ZOOM_RIFLE",
	"ACT_DOD_WALK_ZOOM_RIFLE",
	"ACT_DOD_RUN_ZOOM_RIFLE",
	"ACT_DOD_PRONE_ZOOM_RIFLE",
	"ACT_DOD_STAND_ZOOM_BOLT",
	"ACT_DOD_CROUCH_ZOOM_BOLT",
	"ACT_DOD_CROUCHWALK_ZOOM_BOLT",
	"ACT_DOD_WALK_ZOOM_BOLT",
	"ACT_DOD_RUN_ZOOM_BOLT",
	"ACT_DOD_PRONE_ZOOM_BOLT",
	"ACT_DOD_STAND_ZOOM_BAZOOKA",
	"ACT_DOD_CROUCH_ZOOM_BAZOOKA",
	"ACT_DOD_CROUCHWALK_ZOOM_BAZOOKA",
	"ACT_DOD_WALK_ZOOM_BAZOOKA",
	"ACT_DOD_RUN_ZOOM_BAZOOKA",
	"ACT_DOD_PRONE_ZOOM_BAZOOKA",
	"ACT_DOD_STAND_ZOOM_PSCHRECK",
	"ACT_DOD_CROUCH_ZOOM_PSCHRECK",
	"ACT_DOD_CROUCHWALK_ZOOM_PSCHRECK",
	"ACT_DOD_WALK_ZOOM_PSCHRECK",
	"ACT_DOD_RUN_ZOOM_PSCHRECK",
	"ACT_DOD_PRONE_ZOOM_PSCHRECK",
	"ACT_DOD_DEPLOY_RIFLE",
	"ACT_DOD_DEPLOY_TOMMY",
	"ACT_DOD_DEPLOY_MG",
	"ACT_DOD_DEPLOY_30CAL",
	"ACT_DOD_PRONE_DEPLOY_RIFLE",
	"ACT_DOD_PRONE_DEPLOY_TOMMY",
	"ACT_DOD_PRONE_DEPLOY_MG",
	"ACT_DOD_PRONE_DEPLOY_30CAL",
	"ACT_DOD_PRIMARYATTACK_RIFLE",
	"ACT_DOD_SECONDARYATTACK_RIFLE",
	"ACT_DOD_PRIMARYATTACK_PRONE_RIFLE",
	"ACT_DOD_SECONDARYATTACK_PRONE_RIFLE",
	"ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_RIFLE",
	"ACT_DOD_PRIMARYATTACK_DEPLOYED_RIFLE",
	"ACT_DOD_PRIMARYATTACK_BOLT",
	"ACT_DOD_SECONDARYATTACK_BOLT",
	"ACT_DOD_PRIMARYATTACK_PRONE_BOLT",
	"ACT_DOD_SECONDARYATTACK_PRONE_BOLT",
	"ACT_DOD_PRIMARYATTACK_TOMMY",
	"ACT_DOD_PRIMARYATTACK_PRONE_TOMMY",
	"ACT_DOD_SECONDARYATTACK_TOMMY",
	"ACT_DOD_SECONDARYATTACK_PRONE_TOMMY",
	"ACT_DOD_PRIMARYATTACK_MP40",
	"ACT_DOD_PRIMARYATTACK_PRONE_MP40",
	"ACT_DOD_SECONDARYATTACK_MP40",
	"ACT_DOD_SECONDARYATTACK_PRONE_MP40",
	"ACT_DOD_PRIMARYATTACK_MP44",
	"ACT_DOD_PRIMARYATTACK_PRONE_MP44",
	"ACT_DOD_PRIMARYATTACK_GREASE",
	"ACT_DOD_PRIMARYATTACK_PRONE_GREASE",
	"ACT_DOD_PRIMARYATTACK_PISTOL",
	"ACT_DOD_PRIMARYATTACK_PRONE_PISTOL",
	"ACT_DOD_PRIMARYATTACK_C96",
	"ACT_DOD_PRIMARYATTACK_PRONE_C96",
	"ACT_DOD_PRIMARYATTACK_MG",
	"ACT_DOD_PRIMARYATTACK_PRONE_MG",
	"ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_MG",
	"ACT_DOD_PRIMARYATTACK_DEPLOYED_MG",
	"ACT_DOD_PRIMARYATTACK_30CAL",
	"ACT_DOD_PRIMARYATTACK_PRONE_30CAL",
	"ACT_DOD_PRIMARYATTACK_DEPLOYED_30CAL",
	"ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_30CAL",
	"ACT_DOD_PRIMARYATTACK_GREN_FRAG",
	"ACT_DOD_PRIMARYATTACK_PRONE_GREN_FRAG",
	"ACT_DOD_PRIMARYATTACK_GREN_STICK",
	"ACT_DOD_PRIMARYATTACK_PRONE_GREN_STICK",
	"ACT_DOD_PRIMARYATTACK_KNIFE",
	"ACT_DOD_PRIMARYATTACK_PRONE_KNIFE",
	"ACT_DOD_PRIMARYATTACK_SPADE",
	"ACT_DOD_PRIMARYATTACK_PRONE_SPADE",
	"ACT_DOD_PRIMARYATTACK_BAZOOKA",
	"ACT_DOD_PRIMARYATTACK_PRONE_BAZOOKA",
	"ACT_DOD_PRIMARYATTACK_PSCHRECK",
	"ACT_DOD_PRIMARYATTACK_PRONE_PSCHRECK",
	"ACT_DOD_PRIMARYATTACK_BAR",
	"ACT_DOD_PRIMARYATTACK_PRONE_BAR",
	"ACT_DOD_RELOAD_GARAND",
	"ACT_DOD_RELOAD_K43",
	"ACT_DOD_RELOAD_BAR",
	"ACT_DOD_RELOAD_MP40",
	"ACT_DOD_RELOAD_MP44",
	"ACT_DOD_RELOAD_BOLT",
	"ACT_DOD_RELOAD_M1CARBINE",
	"ACT_DOD_RELOAD_TOMMY",
	"ACT_DOD_RELOAD_GREASEGUN",
	"ACT_DOD_RELOAD_PISTOL",
	"ACT_DOD_RELOAD_FG42",
	"ACT_DOD_RELOAD_RIFLE",
	"ACT_DOD_RELOAD_RIFLEGRENADE",
	"ACT_DOD_RELOAD_C96",
	"ACT_DOD_RELOAD_CROUCH_BAR",
	"ACT_DOD_RELOAD_CROUCH_RIFLE",
	"ACT_DOD_RELOAD_CROUCH_RIFLEGRENADE",
	"ACT_DOD_RELOAD_CROUCH_BOLT",
	"ACT_DOD_RELOAD_CROUCH_MP44",
	"ACT_DOD_RELOAD_CROUCH_MP40",
	"ACT_DOD_RELOAD_CROUCH_TOMMY",
	"ACT_DOD_RELOAD_CROUCH_BAZOOKA",
	"ACT_DOD_RELOAD_CROUCH_PSCHRECK",
	"ACT_DOD_RELOAD_CROUCH_PISTOL",
	"ACT_DOD_RELOAD_CROUCH_M1CARBINE",
	"ACT_DOD_RELOAD_CROUCH_C96",
	"ACT_DOD_RELOAD_BAZOOKA",
	"ACT_DOD_ZOOMLOAD_BAZOOKA",
	"ACT_DOD_RELOAD_PSCHRECK",
	"ACT_DOD_ZOOMLOAD_PSCHRECK",
	"ACT_DOD_RELOAD_DEPLOYED_FG42",
	"ACT_DOD_RELOAD_DEPLOYED_30CAL",
	"ACT_DOD_RELOAD_DEPLOYED_MG",
	"ACT_DOD_RELOAD_DEPLOYED_MG34",
	"ACT_DOD_RELOAD_DEPLOYED_BAR",
	"ACT_DOD_RELOAD_PRONE_PISTOL",
	"ACT_DOD_RELOAD_PRONE_GARAND",
	"ACT_DOD_RELOAD_PRONE_M1CARBINE",
	"ACT_DOD_RELOAD_PRONE_BOLT",
	"ACT_DOD_RELOAD_PRONE_K43",
	"ACT_DOD_RELOAD_PRONE_MP40",
	"ACT_DOD_RELOAD_PRONE_MP44",
	"ACT_DOD_RELOAD_PRONE_BAR",
	"ACT_DOD_RELOAD_PRONE_GREASEGUN",
	"ACT_DOD_RELOAD_PRONE_TOMMY",
	"ACT_DOD_RELOAD_PRONE_FG42",
	"ACT_DOD_RELOAD_PRONE_RIFLE",
	"ACT_DOD_RELOAD_PRONE_RIFLEGRENADE",
	"ACT_DOD_RELOAD_PRONE_C96",
	"ACT_DOD_RELOAD_PRONE_BAZOOKA",
	"ACT_DOD_ZOOMLOAD_PRONE_BAZOOKA",
	"ACT_DOD_RELOAD_PRONE_PSCHRECK",
	"ACT_DOD_ZOOMLOAD_PRONE_PSCHRECK",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED_BAR",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED_FG42",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED_30CAL",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED_MG",
	"ACT_DOD_RELOAD_PRONE_DEPLOYED_MG34",
	"ACT_DOD_PRONE_ZOOM_FORWARD_RIFLE",
	"ACT_DOD_PRONE_ZOOM_FORWARD_BOLT",
	"ACT_DOD_PRONE_ZOOM_FORWARD_BAZOOKA",
	"ACT_DOD_PRONE_ZOOM_FORWARD_PSCHRECK",
	"ACT_DOD_PRIMARYATTACK_CROUCH",
	"ACT_DOD_PRIMARYATTACK_CROUCH_SPADE",
	"ACT_DOD_PRIMARYATTACK_CROUCH_KNIFE",
	"ACT_DOD_PRIMARYATTACK_CROUCH_GREN_FRAG",
	"ACT_DOD_PRIMARYATTACK_CROUCH_GREN_STICK",
	"ACT_DOD_SECONDARYATTACK_CROUCH",
	"ACT_DOD_SECONDARYATTACK_CROUCH_TOMMY",
	"ACT_DOD_SECONDARYATTACK_CROUCH_MP40",
	"ACT_DOD_HS_IDLE",
	"ACT_DOD_HS_CROUCH",
	"ACT_DOD_HS_IDLE_30CAL",
	"ACT_DOD_HS_IDLE_BAZOOKA",
	"ACT_DOD_HS_IDLE_PSCHRECK",
	"ACT_DOD_HS_IDLE_KNIFE",
	"ACT_DOD_HS_IDLE_MG42",
	"ACT_DOD_HS_IDLE_PISTOL",
	"ACT_DOD_HS_IDLE_STICKGRENADE",
	"ACT_DOD_HS_IDLE_TOMMY",
	"ACT_DOD_HS_IDLE_MP44",
	"ACT_DOD_HS_IDLE_K98",
	"ACT_DOD_HS_CROUCH_30CAL",
	"ACT_DOD_HS_CROUCH_BAZOOKA",
	"ACT_DOD_HS_CROUCH_PSCHRECK",
	"ACT_DOD_HS_CROUCH_KNIFE",
	"ACT_DOD_HS_CROUCH_MG42",
	"ACT_DOD_HS_CROUCH_PISTOL",
	"ACT_DOD_HS_CROUCH_STICKGRENADE",
	"ACT_DOD_HS_CROUCH_TOMMY",
	"ACT_DOD_HS_CROUCH_MP44",
	"ACT_DOD_HS_CROUCH_K98",
	"ACT_DOD_STAND_IDLE_TNT",
	"ACT_DOD_CROUCH_IDLE_TNT",
	"ACT_DOD_CROUCHWALK_IDLE_TNT",
	"ACT_DOD_WALK_IDLE_TNT",
	"ACT_DOD_RUN_IDLE_TNT",
	"ACT_DOD_SPRINT_IDLE_TNT",
	"ACT_DOD_PRONEWALK_IDLE_TNT",
	"ACT_DOD_PLANT_TNT",
	"ACT_DOD_DEFUSE_TNT",
	"ACT_HL2MP_ALYXGUN_SMG_HOLSTER,//",
	"ACT_HL2MP_IDLE",
	"ACT_HL2MP_RUN",
	"ACT_HL2MP_IDLE_CROUCH",
	"ACT_HL2MP_WALK_CROUCH",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK",
	"ACT_HL2MP_GESTURE_RELOAD",
	"ACT_HL2MP_JUMP",
	"ACT_HL2MP_IDLE_PISTOL",
	"ACT_HL2MP_RUN_PISTOL",
	"ACT_HL2MP_IDLE_CROUCH_PISTOL",
	"ACT_HL2MP_WALK_CROUCH_PISTOL",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL",
	"ACT_HL2MP_GESTURE_RELOAD_PISTOL",
	"ACT_HL2MP_JUMP_PISTOL",
	"ACT_HL2MP_IDLE_SMG1",
	"ACT_HL2MP_RUN_SMG1",
	"ACT_HL2MP_IDLE_CROUCH_SMG1",
	"ACT_HL2MP_WALK_CROUCH_SMG1",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1",
	"ACT_HL2MP_GESTURE_RELOAD_SMG1",
	"ACT_HL2MP_JUMP_SMG1",
	"ACT_HL2MP_IDLE_AR2",
	"ACT_HL2MP_RUN_AR2",
	"ACT_HL2MP_IDLE_CROUCH_AR2",
	"ACT_HL2MP_WALK_CROUCH_AR2",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2",
	"ACT_HL2MP_GESTURE_RELOAD_AR2",
	"ACT_HL2MP_JUMP_AR2",
	"ACT_HL2MP_IDLE_SHOTGUN",
	"ACT_HL2MP_RUN_SHOTGUN",
	"ACT_HL2MP_IDLE_CROUCH_SHOTGUN",
	"ACT_HL2MP_WALK_CROUCH_SHOTGUN",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN",
	"ACT_HL2MP_GESTURE_RELOAD_SHOTGUN",
	"ACT_HL2MP_JUMP_SHOTGUN",
	"ACT_HL2MP_IDLE_RPG",
	"ACT_HL2MP_RUN_RPG",
	"ACT_HL2MP_IDLE_CROUCH_RPG",
	"ACT_HL2MP_WALK_CROUCH_RPG",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG",
	"ACT_HL2MP_GESTURE_RELOAD_RPG",
	"ACT_HL2MP_JUMP_RPG",
	"ACT_HL2MP_IDLE_GRENADE",
	"ACT_HL2MP_RUN_GRENADE",
	"ACT_HL2MP_IDLE_CROUCH_GRENADE",
	"ACT_HL2MP_WALK_CROUCH_GRENADE",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE",
	"ACT_HL2MP_GESTURE_RELOAD_GRENADE",
	"ACT_HL2MP_JUMP_GRENADE",
	"ACT_HL2MP_IDLE_PHYSGUN",
	"ACT_HL2MP_RUN_PHYSGUN",
	"ACT_HL2MP_IDLE_CROUCH_PHYSGUN",
	"ACT_HL2MP_WALK_CROUCH_PHYSGUN",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN",
	"ACT_HL2MP_GESTURE_RELOAD_PHYSGUN",
	"ACT_HL2MP_JUMP_PHYSGUN",
	"ACT_HL2MP_IDLE_CROSSBOW",
	"ACT_HL2MP_RUN_CROSSBOW",
	"ACT_HL2MP_IDLE_CROUCH_CROSSBOW",
	"ACT_HL2MP_WALK_CROUCH_CROSSBOW",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW",
	"ACT_HL2MP_GESTURE_RELOAD_CROSSBOW",
	"ACT_HL2MP_JUMP_CROSSBOW",
	"ACT_HL2MP_IDLE_MELEE",
	"ACT_HL2MP_RUN_MELEE",
	"ACT_HL2MP_IDLE_CROUCH_MELEE",
	"ACT_HL2MP_WALK_CROUCH_MELEE",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE",
	"ACT_HL2MP_GESTURE_RELOAD_MELEE",
	"ACT_HL2MP_JUMP_MELEE",
	"ACT_HL2MP_IDLE_SLAM",
	"ACT_HL2MP_RUN_SLAM",
	"ACT_HL2MP_IDLE_CROUCH_SLAM",
	"ACT_HL2MP_WALK_CROUCH_SLAM",
	"ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM",
	"ACT_HL2MP_GESTURE_RELOAD_SLAM",
	"ACT_HL2MP_JUMP_SLAM",
	"ACT_VM_FIZZLE",
	"ACT_MP_STAND_IDLE",
	"ACT_MP_CROUCH_IDLE",
	"ACT_MP_CROUCH_DEPLOYED_IDLE",
	"ACT_MP_CROUCH_DEPLOYED",
	"ACT_MP_CROUCHWALK_DEPLOYED",
	"ACT_MP_DEPLOYED_IDLE",
	"ACT_MP_RUN",
	"ACT_MP_WALK",
	"ACT_MP_AIRWALK",
	"ACT_MP_CROUCHWALK",
	"ACT_MP_SPRINT",
	"ACT_MP_JUMP",
	"ACT_MP_JUMP_START",
	"ACT_MP_JUMP_FLOAT",
	"ACT_MP_JUMP_LAND",
	"ACT_MP_DOUBLEJUMP",
	"ACT_MP_SWIM",
	"ACT_MP_DEPLOYED",
	"ACT_MP_SWIM_DEPLOYED",
	"ACT_MP_VCD",
	"ACT_MP_ATTACK_STAND_PRIMARYFIRE",
	"ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED",
	"ACT_MP_ATTACK_STAND_SECONDARYFIRE",
	"ACT_MP_ATTACK_STAND_GRENADE",
	"ACT_MP_ATTACK_CROUCH_PRIMARYFIRE",
	"ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED",
	"ACT_MP_ATTACK_CROUCH_SECONDARYFIRE",
	"ACT_MP_ATTACK_CROUCH_GRENADE",
	"ACT_MP_ATTACK_SWIM_PRIMARYFIRE",
	"ACT_MP_ATTACK_SWIM_SECONDARYFIRE",
	"ACT_MP_ATTACK_SWIM_GRENADE",
	"ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE",
	"ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE",
	"ACT_MP_ATTACK_AIRWALK_GRENADE",
	"ACT_MP_RELOAD_STAND",
	"ACT_MP_RELOAD_STAND_LOOP",
	"ACT_MP_RELOAD_STAND_END",
	"ACT_MP_RELOAD_CROUCH",
	"ACT_MP_RELOAD_CROUCH_LOOP",
	"ACT_MP_RELOAD_CROUCH_END",
	"ACT_MP_RELOAD_SWIM",
	"ACT_MP_RELOAD_SWIM_LOOP",
	"ACT_MP_RELOAD_SWIM_END",
	"ACT_MP_RELOAD_AIRWALK",
	"ACT_MP_RELOAD_AIRWALK_LOOP",
	"ACT_MP_RELOAD_AIRWALK_END",
	"ACT_MP_ATTACK_STAND_PREFIRE",
	"ACT_MP_ATTACK_STAND_POSTFIRE",
	"ACT_MP_ATTACK_STAND_STARTFIRE",
	"ACT_MP_ATTACK_CROUCH_PREFIRE",
	"ACT_MP_ATTACK_CROUCH_POSTFIRE",
	"ACT_MP_ATTACK_SWIM_PREFIRE",
	"ACT_MP_ATTACK_SWIM_POSTFIRE",
	"ACT_MP_STAND_PRIMARY",
	"ACT_MP_CROUCH_PRIMARY",
	"ACT_MP_RUN_PRIMARY",
	"ACT_MP_WALK_PRIMARY",
	"ACT_MP_AIRWALK_PRIMARY",
	"ACT_MP_CROUCHWALK_PRIMARY",
	"ACT_MP_JUMP_PRIMARY",
	"ACT_MP_JUMP_START_PRIMARY",
	"ACT_MP_JUMP_FLOAT_PRIMARY",
	"ACT_MP_JUMP_LAND_PRIMARY",
	"ACT_MP_SWIM_PRIMARY",
	"ACT_MP_DEPLOYED_PRIMARY",
	"ACT_MP_SWIM_DEPLOYED_PRIMARY",
	"ACT_MP_CROUCHWALK_DEPLOYED_PRIMARY",
	"ACT_MP_CROUCH_DEPLOYED_IDLE_PRIMARY",
	"ACT_MP_ATTACK_STAND_PRIMARY",
	"ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED",
	"ACT_MP_ATTACK_CROUCH_PRIMARY",
	"ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED",
	"ACT_MP_ATTACK_SWIM_PRIMARY",
	"ACT_MP_ATTACK_AIRWALK_PRIMARY",
	"ACT_MP_RELOAD_STAND_PRIMARY",
	"ACT_MP_RELOAD_STAND_PRIMARY_LOOP",
	"ACT_MP_RELOAD_STAND_PRIMARY_END",
	"ACT_MP_RELOAD_CROUCH_PRIMARY",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_END",
	"ACT_MP_RELOAD_SWIM_PRIMARY",
	"ACT_MP_RELOAD_SWIM_PRIMARY_LOOP",
	"ACT_MP_RELOAD_SWIM_PRIMARY_END",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_END",
	"ACT_MP_RELOAD_STAND_PRIMARY_2",
	"ACT_MP_RELOAD_STAND_PRIMARY_LOOP_2",
	"ACT_MP_RELOAD_STAND_PRIMARY_END_2",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_2",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP_2",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_END_2",
	"ACT_MP_RELOAD_SWIM_PRIMARY_2",
	"ACT_MP_RELOAD_SWIM_PRIMARY_LOOP_2",
	"ACT_MP_RELOAD_SWIM_PRIMARY_END_2",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_2",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP_2",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_END_2",
	"ACT_MP_ATTACK_STAND_PRIMARY_ALT",
	"ACT_MP_ATTACK_CROUCH_PRIMARY_ALT",
	"ACT_MP_ATTACK_SWIM_PRIMARY_ALT",
	"ACT_MP_RELOAD_STAND_PRIMARY_ALT",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_ALT",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_ALT",
	"ACT_MP_RELOAD_STAND_PRIMARY_LOOP_ALT",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP_ALT",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP_ALT",
	"ACT_MP_RELOAD_STAND_PRIMARY_END_ALT",
	"ACT_MP_RELOAD_CROUCH_PRIMARY_END_ALT",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY_END_ALT",
	"ACT_MP_RELOAD_SWIM_PRIMARY_ALT",
	"ACT_MP_ATTACK_STAND_PRIMARY_SUPER",
	"ACT_MP_ATTACK_CROUCH_PRIMARY_SUPER",
	"ACT_MP_ATTACK_SWIM_PRIMARY_SUPER",
	"ACT_MP_ATTACK_STAND_GRENADE_PRIMARY",
	"ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY",
	"ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY",
	"ACT_MP_STAND_SECONDARY",
	"ACT_MP_CROUCH_SECONDARY",
	"ACT_MP_RUN_SECONDARY",
	"ACT_MP_WALK_SECONDARY",
	"ACT_MP_AIRWALK_SECONDARY",
	"ACT_MP_CROUCHWALK_SECONDARY",
	"ACT_MP_JUMP_SECONDARY",
	"ACT_MP_JUMP_START_SECONDARY",
	"ACT_MP_JUMP_FLOAT_SECONDARY",
	"ACT_MP_JUMP_LAND_SECONDARY",
	"ACT_MP_SWIM_SECONDARY",
	"ACT_MP_ATTACK_STAND_SECONDARY",
	"ACT_MP_ATTACK_CROUCH_SECONDARY",
	"ACT_MP_ATTACK_SWIM_SECONDARY",
	"ACT_MP_ATTACK_AIRWALK_SECONDARY",
	"ACT_MP_RELOAD_STAND_SECONDARY",
	"ACT_MP_RELOAD_STAND_SECONDARY_LOOP",
	"ACT_MP_RELOAD_STAND_SECONDARY_END",
	"ACT_MP_RELOAD_CROUCH_SECONDARY",
	"ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP",
	"ACT_MP_RELOAD_CROUCH_SECONDARY_END",
	"ACT_MP_RELOAD_SWIM_SECONDARY",
	"ACT_MP_RELOAD_SWIM_SECONDARY_LOOP",
	"ACT_MP_RELOAD_SWIM_SECONDARY_END",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY_END",
	"ACT_MP_RELOAD_STAND_SECONDARY_2",
	"ACT_MP_RELOAD_CROUCH_SECONDARY_2",
	"ACT_MP_RELOAD_SWIM_SECONDARY_2",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY_2",
	"ACT_MP_ATTACK_STAND_GRENADE_SECONDARY",
	"ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY",
	"ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY",
	"ACT_MP_STAND_SECONDARY2",
	"ACT_MP_CROUCH_SECONDARY2",
	"ACT_MP_RUN_SECONDARY2",
	"ACT_MP_WALK_SECONDARY2",
	"ACT_MP_AIRWALK_SECONDARY2",
	"ACT_MP_CROUCHWALK_SECONDARY2",
	"ACT_MP_JUMP_SECONDARY2",
	"ACT_MP_JUMP_START_SECONDARY2",
	"ACT_MP_JUMP_FLOAT_SECONDARY2",
	"ACT_MP_JUMP_LAND_SECONDARY2",
	"ACT_MP_SWIM_SECONDARY2",
	"ACT_MP_ATTACK_STAND_SECONDARY2",
	"ACT_MP_ATTACK_CROUCH_SECONDARY2",
	"ACT_MP_ATTACK_SWIM_SECONDARY2",
	"ACT_MP_ATTACK_AIRWALK_SECONDARY2",
	"ACT_MP_RELOAD_STAND_SECONDARY2",
	"ACT_MP_RELOAD_STAND_SECONDARY2_LOOP",
	"ACT_MP_RELOAD_STAND_SECONDARY2_END",
	"ACT_MP_RELOAD_CROUCH_SECONDARY2",
	"ACT_MP_RELOAD_CROUCH_SECONDARY2_LOOP",
	"ACT_MP_RELOAD_CROUCH_SECONDARY2_END",
	"ACT_MP_RELOAD_SWIM_SECONDARY2",
	"ACT_MP_RELOAD_SWIM_SECONDARY2_LOOP",
	"ACT_MP_RELOAD_SWIM_SECONDARY2_END",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY2",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY2_LOOP",
	"ACT_MP_RELOAD_AIRWALK_SECONDARY2_END",
	"ACT_MP_STAND_MELEE",
	"ACT_MP_CROUCH_MELEE",
	"ACT_MP_RUN_MELEE",
	"ACT_MP_WALK_MELEE",
	"ACT_MP_AIRWALK_MELEE",
	"ACT_MP_CROUCHWALK_MELEE",
	"ACT_MP_JUMP_MELEE",
	"ACT_MP_JUMP_START_MELEE",
	"ACT_MP_JUMP_FLOAT_MELEE",
	"ACT_MP_JUMP_LAND_MELEE",
	"ACT_MP_SWIM_MELEE",
	"ACT_MP_ATTACK_STAND_MELEE",
	"ACT_MP_ATTACK_STAND_MELEE_SECONDARY",
	"ACT_MP_ATTACK_CROUCH_MELEE",
	"ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY",
	"ACT_MP_ATTACK_SWIM_MELEE",
	"ACT_MP_ATTACK_AIRWALK_MELEE",
	"ACT_MP_ATTACK_STAND_GRENADE_MELEE",
	"ACT_MP_ATTACK_CROUCH_GRENADE_MELEE",
	"ACT_MP_ATTACK_SWIM_GRENADE_MELEE",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE",
	"ACT_MP_STAND_ITEM1",
	"ACT_MP_CROUCH_ITEM1",
	"ACT_MP_RUN_ITEM1",
	"ACT_MP_WALK_ITEM1",
	"ACT_MP_AIRWALK_ITEM1",
	"ACT_MP_CROUCHWALK_ITEM1",
	"ACT_MP_JUMP_ITEM1",
	"ACT_MP_JUMP_START_ITEM1",
	"ACT_MP_JUMP_FLOAT_ITEM1",
	"ACT_MP_JUMP_LAND_ITEM1",
	"ACT_MP_SWIM_ITEM1",
	"ACT_MP_ATTACK_STAND_ITEM1",
	"ACT_MP_ATTACK_STAND_ITEM1_SECONDARY",
	"ACT_MP_ATTACK_CROUCH_ITEM1",
	"ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY",
	"ACT_MP_ATTACK_SWIM_ITEM1",
	"ACT_MP_ATTACK_AIRWALK_ITEM1",
	"ACT_MP_DEPLOYED_ITEM1",
	"ACT_MP_DEPLOYED_IDLE_ITEM1",
	"ACT_MP_CROUCHWALK_DEPLOYED_ITEM1",
	"ACT_MP_CROUCH_DEPLOYED_IDLE_ITEM1",
	"ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED_ITEM1",
	"ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED_ITEM1",
	"ACT_MP_STAND_ITEM2",
	"ACT_MP_CROUCH_ITEM2",
	"ACT_MP_RUN_ITEM2",
	"ACT_MP_WALK_ITEM2",
	"ACT_MP_AIRWALK_ITEM2",
	"ACT_MP_CROUCHWALK_ITEM2",
	"ACT_MP_JUMP_ITEM2",
	"ACT_MP_JUMP_START_ITEM2",
	"ACT_MP_JUMP_FLOAT_ITEM2",
	"ACT_MP_JUMP_LAND_ITEM2",
	"ACT_MP_SWIM_ITEM2",
	"ACT_MP_ATTACK_STAND_ITEM2",
	"ACT_MP_ATTACK_STAND_ITEM2_SECONDARY",
	"ACT_MP_ATTACK_CROUCH_ITEM2",
	"ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY",
	"ACT_MP_ATTACK_SWIM_ITEM2",
	"ACT_MP_ATTACK_AIRWALK_ITEM2",
	"ACT_MP_ATTACK_STAND_HARD_ITEM2",
	"ACT_MP_ATTACK_CROUCH_HARD_ITEM2",
	"ACT_MP_ATTACK_SWIM_HARD_ITEM2",
	"ACT_MP_DEPLOYED_ITEM2",
	"ACT_MP_DEPLOYED_IDLE_ITEM2",
	"ACT_MP_CROUCHWALK_DEPLOYED_ITEM2",
	"ACT_MP_CROUCH_DEPLOYED_IDLE_ITEM2",
	"ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED_ITEM2",
	"ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED_ITEM2",
	"ACT_MP_RELOAD_STAND_ITEM2",
	"ACT_MP_RELOAD_STAND_ITEM2_LOOP",
	"ACT_MP_RELOAD_STAND_ITEM2_END",
	"ACT_MP_RELOAD_CROUCH_ITEM2",
	"ACT_MP_RELOAD_CROUCH_ITEM2_LOOP",
	"ACT_MP_RELOAD_CROUCH_ITEM2_END",
	"ACT_MP_RELOAD_SWIM_ITEM2",
	"ACT_MP_RELOAD_SWIM_ITEM2_LOOP",
	"ACT_MP_RELOAD_SWIM_ITEM2_END",
	"ACT_MP_RELOAD_AIRWALK_ITEM2",
	"ACT_MP_RELOAD_AIRWALK_ITEM2_LOOP",
	"ACT_MP_RELOAD_AIRWALK_ITEM2_END",
	"ACT_MP_RELOAD_NO_AMMO_ITEM2",
	"ACT_MP_ATTACK_STAND_GRENADE_ITEM2",
	"ACT_MP_ATTACK_CROUCH_GRENADE_ITEM2",
	"ACT_MP_ATTACK_SWIM_GRENADE_ITEM2",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_ITEM2",
	"ACT_MP_GESTURE_FLINCH",
	"ACT_MP_GESTURE_FLINCH_PRIMARY",
	"ACT_MP_GESTURE_FLINCH_SECONDARY",
	"ACT_MP_GESTURE_FLINCH_MELEE",
	"ACT_MP_GESTURE_FLINCH_ITEM1",
	"ACT_MP_GESTURE_FLINCH_ITEM2",
	"ACT_MP_GESTURE_FLINCH_HEAD",
	"ACT_MP_GESTURE_FLINCH_CHEST",
	"ACT_MP_GESTURE_FLINCH_STOMACH",
	"ACT_MP_GESTURE_FLINCH_LEFTARM",
	"ACT_MP_GESTURE_FLINCH_RIGHTARM",
	"ACT_MP_GESTURE_FLINCH_LEFTLEG",
	"ACT_MP_GESTURE_FLINCH_RIGHTLEG",
	"ACT_MP_GRENADE1_DRAW",
	"ACT_MP_GRENADE1_IDLE",
	"ACT_MP_GRENADE1_ATTACK",
	"ACT_MP_GRENADE2_DRAW",
	"ACT_MP_GRENADE2_IDLE",
	"ACT_MP_GRENADE2_ATTACK",
	"ACT_MP_PRIMARY_GRENADE1_DRAW",
	"ACT_MP_PRIMARY_GRENADE1_IDLE",
	"ACT_MP_PRIMARY_GRENADE1_ATTACK",
	"ACT_MP_PRIMARY_GRENADE2_DRAW",
	"ACT_MP_PRIMARY_GRENADE2_IDLE",
	"ACT_MP_PRIMARY_GRENADE2_ATTACK",
	"ACT_MP_SECONDARY_GRENADE1_DRAW",
	"ACT_MP_SECONDARY_GRENADE1_IDLE",
	"ACT_MP_SECONDARY_GRENADE1_ATTACK",
	"ACT_MP_SECONDARY_GRENADE2_DRAW",
	"ACT_MP_SECONDARY_GRENADE2_IDLE",
	"ACT_MP_SECONDARY_GRENADE2_ATTACK",
	"ACT_MP_MELEE_GRENADE1_DRAW",
	"ACT_MP_MELEE_GRENADE1_IDLE",
	"ACT_MP_MELEE_GRENADE1_ATTACK",
	"ACT_MP_MELEE_GRENADE2_DRAW",
	"ACT_MP_MELEE_GRENADE2_IDLE",
	"ACT_MP_MELEE_GRENADE2_ATTACK",
	"ACT_MP_ITEM1_GRENADE1_DRAW",
	"ACT_MP_ITEM1_GRENADE1_IDLE",
	"ACT_MP_ITEM1_GRENADE1_ATTACK",
	"ACT_MP_ITEM1_GRENADE2_DRAW",
	"ACT_MP_ITEM1_GRENADE2_IDLE",
	"ACT_MP_ITEM1_GRENADE2_ATTACK",
	"ACT_MP_ITEM2_GRENADE1_DRAW",
	"ACT_MP_ITEM2_GRENADE1_IDLE",
	"ACT_MP_ITEM2_GRENADE1_ATTACK",
	"ACT_MP_ITEM2_GRENADE2_DRAW",
	"ACT_MP_ITEM2_GRENADE2_IDLE",
	"ACT_MP_ITEM2_GRENADE2_ATTACK",
	"ACT_MP_STAND_BUILDING",
	"ACT_MP_CROUCH_BUILDING",
	"ACT_MP_RUN_BUILDING",
	"ACT_MP_WALK_BUILDING",
	"ACT_MP_AIRWALK_BUILDING",
	"ACT_MP_CROUCHWALK_BUILDING",
	"ACT_MP_JUMP_BUILDING",
	"ACT_MP_JUMP_START_BUILDING",
	"ACT_MP_JUMP_FLOAT_BUILDING",
	"ACT_MP_JUMP_LAND_BUILDING",
	"ACT_MP_SWIM_BUILDING",
	"ACT_MP_ATTACK_STAND_BUILDING",
	"ACT_MP_ATTACK_CROUCH_BUILDING",
	"ACT_MP_ATTACK_SWIM_BUILDING",
	"ACT_MP_ATTACK_AIRWALK_BUILDING",
	"ACT_MP_ATTACK_STAND_GRENADE_BUILDING",
	"ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING",
	"ACT_MP_ATTACK_SWIM_GRENADE_BUILDING",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING",
	"ACT_MP_STAND_BUILDING_DEPLOYED",
	"ACT_MP_CROUCH_BUILDING_DEPLOYED",
	"ACT_MP_RUN_BUILDING_DEPLOYED",
	"ACT_MP_WALK_BUILDING_DEPLOYED",
	"ACT_MP_AIRWALK_BUILDING_DEPLOYED",
	"ACT_MP_CROUCHWALK_BUILDING_DEPLOYED",
	"ACT_MP_JUMP_BUILDING_DEPLOYED",
	"ACT_MP_JUMP_START_BUILDING_DEPLOYED",
	"ACT_MP_JUMP_FLOAT_BUILDING_DEPLOYED",
	"ACT_MP_JUMP_LAND_BUILDING_DEPLOYED",
	"ACT_MP_SWIM_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_STAND_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_CROUCH_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_SWIM_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_AIRWALK_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_STAND_GRENADE_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_SWIM_GRENADE_BUILDING_DEPLOYED",
	"ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING_DEPLOYED",
	"ACT_MP_STAND_PDA",
	"ACT_MP_CROUCH_PDA",
	"ACT_MP_RUN_PDA",
	"ACT_MP_WALK_PDA",
	"ACT_MP_AIRWALK_PDA",
	"ACT_MP_CROUCHWALK_PDA",
	"ACT_MP_JUMP_PDA",
	"ACT_MP_JUMP_START_PDA",
	"ACT_MP_JUMP_FLOAT_PDA",
	"ACT_MP_JUMP_LAND_PDA",
	"ACT_MP_SWIM_PDA",
	"ACT_MP_ATTACK_STAND_PDA",
	"ACT_MP_ATTACK_SWIM_PDA",
	"ACT_MP_STAND_LOSERSTATE",
	"ACT_MP_CROUCH_LOSERSTATE",
	"ACT_MP_RUN_LOSERSTATE",
	"ACT_MP_WALK_LOSERSTATE",
	"ACT_MP_AIRWALK_LOSERSTATE",
	"ACT_MP_CROUCHWALK_LOSERSTATE",
	"ACT_MP_JUMP_LOSERSTATE",
	"ACT_MP_JUMP_START_LOSERSTATE",
	"ACT_MP_JUMP_FLOAT_LOSERSTATE",
	"ACT_MP_JUMP_LAND_LOSERSTATE",
	"ACT_MP_SWIM_LOSERSTATE",
	"ACT_MP_DOUBLEJUMP_LOSERSTATE",
	"ACT_MP_DOUBLEJUMP_CROUCH",
	"ACT_MP_DOUBLEJUMP_CROUCH_PRIMARY",
	"ACT_MP_DOUBLEJUMP_CROUCH_SECONDARY",
	"ACT_MP_DOUBLEJUMP_CROUCH_MELEE",
	"ACT_MP_DOUBLEJUMP_CROUCH_ITEM1",
	"ACT_MP_DOUBLEJUMP_CROUCH_ITEM2",
	"ACT_MP_DOUBLEJUMP_CROUCH_LOSERSTATE",
	"ACT_MP_GESTURE_VC_HANDMOUTH",
	"ACT_MP_GESTURE_VC_FINGERPOINT",
	"ACT_MP_GESTURE_VC_FISTPUMP",
	"ACT_MP_GESTURE_VC_THUMBSUP",
	"ACT_MP_GESTURE_VC_NODYES",
	"ACT_MP_GESTURE_VC_NODNO",
	"ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY",
	"ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY",
	"ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY",
	"ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY",
	"ACT_MP_GESTURE_VC_NODYES_PRIMARY",
	"ACT_MP_GESTURE_VC_NODNO_PRIMARY",
	"ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY",
	"ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY",
	"ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY",
	"ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY",
	"ACT_MP_GESTURE_VC_NODYES_SECONDARY",
	"ACT_MP_GESTURE_VC_NODNO_SECONDARY",
	"ACT_MP_GESTURE_VC_HANDMOUTH_MELEE",
	"ACT_MP_GESTURE_VC_FINGERPOINT_MELEE",
	"ACT_MP_GESTURE_VC_FISTPUMP_MELEE",
	"ACT_MP_GESTURE_VC_THUMBSUP_MELEE",
	"ACT_MP_GESTURE_VC_NODYES_MELEE",
	"ACT_MP_GESTURE_VC_NODNO_MELEE",
	"ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1",
	"ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1",
	"ACT_MP_GESTURE_VC_FISTPUMP_ITEM1",
	"ACT_MP_GESTURE_VC_THUMBSUP_ITEM1",
	"ACT_MP_GESTURE_VC_NODYES_ITEM1",
	"ACT_MP_GESTURE_VC_NODNO_ITEM1",
	"ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2",
	"ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2",
	"ACT_MP_GESTURE_VC_FISTPUMP_ITEM2",
	"ACT_MP_GESTURE_VC_THUMBSUP_ITEM2",
	"ACT_MP_GESTURE_VC_NODYES_ITEM2",
	"ACT_MP_GESTURE_VC_NODNO_ITEM2",
	"ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING",
	"ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING",
	"ACT_MP_GESTURE_VC_FISTPUMP_BUILDING",
	"ACT_MP_GESTURE_VC_THUMBSUP_BUILDING",
	"ACT_MP_GESTURE_VC_NODYES_BUILDING",
	"ACT_MP_GESTURE_VC_NODNO_BUILDING",
	"ACT_MP_GESTURE_VC_HANDMOUTH_PDA",
	"ACT_MP_GESTURE_VC_FINGERPOINT_PDA",
	"ACT_MP_GESTURE_VC_FISTPUMP_PDA",
	"ACT_MP_GESTURE_VC_THUMBSUP_PDA",
	"ACT_MP_GESTURE_VC_NODYES_PDA",
	"ACT_MP_GESTURE_VC_NODNO_PDA",
	"ACT_MP_STUN_BEGIN",
	"ACT_MP_STUN_MIDDLE",
	"ACT_MP_STUN_END",
	"ACT_VM_UNUSABLE",
	"ACT_VM_UNUSABLE_TO_USABLE",
	"ACT_VM_USABLE_TO_UNUSABLE",
	"ACT_PRIMARY_VM_DRAW",
	"ACT_PRIMARY_VM_HOLSTER",
	"ACT_PRIMARY_VM_IDLE",
	"ACT_PRIMARY_VM_PULLBACK",
	"ACT_PRIMARY_VM_PRIMARYATTACK",
	"ACT_PRIMARY_VM_SECONDARYATTACK",
	"ACT_PRIMARY_VM_RELOAD",
	"ACT_PRIMARY_RELOAD_START",
	"ACT_PRIMARY_RELOAD_FINISH",
	"ACT_PRIMARY_VM_DRYFIRE",
	"ACT_PRIMARY_VM_IDLE_TO_LOWERED",
	"ACT_PRIMARY_VM_IDLE_LOWERED",
	"ACT_PRIMARY_VM_LOWERED_TO_IDLE",
	"ACT_PRIMARY_VM_RELOAD_2",
	"ACT_PRIMARY_RELOAD_START_2",
	"ACT_PRIMARY_RELOAD_FINISH_2",
	"ACT_PRIMARY_VM_RELOAD_3",
	"ACT_PRIMARY_RELOAD_START_3",
	"ACT_PRIMARY_RELOAD_FINISH_3",
	"ACT_PRIMARY_VM_PRIMARYATTACK_3",
	"ACT_SECONDARY_VM_DRAW",
	"ACT_SECONDARY_VM_HOLSTER",
	"ACT_SECONDARY_VM_IDLE",
	"ACT_SECONDARY_VM_PULLBACK",
	"ACT_SECONDARY_VM_PRIMARYATTACK",
	"ACT_SECONDARY_VM_SECONDARYATTACK",
	"ACT_SECONDARY_VM_RELOAD",
	"ACT_SECONDARY_RELOAD_START",
	"ACT_SECONDARY_RELOAD_FINISH",
	"ACT_SECONDARY_VM_RELOAD2",
	"ACT_SECONDARY_VM_DRYFIRE",
	"ACT_SECONDARY_VM_IDLE_TO_LOWERED",
	"ACT_SECONDARY_VM_IDLE_LOWERED",
	"ACT_SECONDARY_VM_LOWERED_TO_IDLE",
	"ACT_SECONDARY_VM_DRAW_2",
	"ACT_SECONDARY_VM_IDLE_2",
	"ACT_SECONDARY_VM_PRIMARYATTACK_2",
	"ACT_SECONDARY_VM_RELOAD_2",
	"ACT_MELEE_VM_DRAW",
	"ACT_MELEE_VM_HOLSTER",
	"ACT_MELEE_VM_IDLE",
	"ACT_MELEE_VM_PULLBACK",
	"ACT_MELEE_VM_PRIMARYATTACK",
	"ACT_MELEE_VM_SECONDARYATTACK",
	"ACT_MELEE_VM_RELOAD",
	"ACT_MELEE_VM_DRYFIRE",
	"ACT_MELEE_VM_IDLE_TO_LOWERED",
	"ACT_MELEE_VM_IDLE_LOWERED",
	"ACT_MELEE_VM_LOWERED_TO_IDLE",
	"ACT_MELEE_VM_STUN",
	"ACT_MELEE_VM_HITCENTER",
	"ACT_MELEE_VM_SWINGHARD",
	"ACT_PDA_VM_DRAW",
	"ACT_PDA_VM_HOLSTER",
	"ACT_PDA_VM_IDLE",
	"ACT_PDA_VM_PULLBACK",
	"ACT_PDA_VM_PRIMARYATTACK",
	"ACT_PDA_VM_SECONDARYATTACK",
	"ACT_PDA_VM_RELOAD",
	"ACT_PDA_VM_DRYFIRE",
	"ACT_PDA_VM_IDLE_TO_LOWERED",
	"ACT_PDA_VM_IDLE_LOWERED",
	"ACT_PDA_VM_LOWERED_TO_IDLE",
	"ACT_ENGINEER_PDA1_VM_DRAW",
	"ACT_ENGINEER_PDA2_VM_DRAW",
	"ACT_ENGINEER_BLD_VM_DRAW",
	"ACT_ENGINEER_PDA1_VM_IDLE",
	"ACT_ENGINEER_PDA2_VM_IDLE",
	"ACT_ENGINEER_BLD_VM_IDLE",
	"ACT_ITEM1_VM_DRAW",
	"ACT_ITEM1_VM_HOLSTER",
	"ACT_ITEM1_VM_IDLE",
	"ACT_ITEM1_VM_IDLE_2",
	"ACT_ITEM1_VM_PULLBACK",
	"ACT_ITEM1_VM_PRIMARYATTACK",
	"ACT_ITEM1_VM_SECONDARYATTACK",
	"ACT_ITEM1_VM_RELOAD",
	"ACT_ITEM1_VM_DRYFIRE",
	"ACT_ITEM1_VM_IDLE_TO_LOWERED",
	"ACT_ITEM1_VM_IDLE_LOWERED",
	"ACT_ITEM1_VM_LOWERED_TO_IDLE",
	"ACT_ITEM1_RELOAD_START",
	"ACT_ITEM1_RELOAD_FINISH",
	"ACT_ITEM1_VM_HITCENTER",
	"ACT_ITEM1_VM_SWINGHARD",
	"ACT_ITEM1_BACKSTAB_VM_UP",
	"ACT_ITEM1_BACKSTAB_VM_DOWN",
	"ACT_ITEM1_BACKSTAB_VM_IDLE",
	"ACT_MELEE_VM_ITEM1_STUN",
	"ACT_ITEM2_VM_DRAW",
	"ACT_ITEM2_VM_HOLSTER",
	"ACT_ITEM2_VM_IDLE",
	"ACT_ITEM2_VM_PULLBACK",
	"ACT_ITEM2_VM_PRIMARYATTACK",
	"ACT_ITEM2_VM_SECONDARYATTACK",
	"ACT_ITEM2_VM_RELOAD",
	"ACT_ITEM2_VM_DRYFIRE",
	"ACT_ITEM2_VM_IDLE_TO_LOWERED",
	"ACT_ITEM2_VM_IDLE_LOWERED",
	"ACT_ITEM2_VM_LOWERED_TO_IDLE",
	"ACT_ITEM2_VM_CHARGE",
	"ACT_ITEM2_VM_IDLE_2",
	"ACT_ITEM2_VM_IDLE_3",
	"ACT_ITEM2_VM_CHARGE_IDLE_3",
	"ACT_ITEM2_VM_HITCENTER",
	"ACT_ITEM2_VM_SWINGHARD",
	"ACT_ITEM2_BACKSTAB_VM_UP",
	"ACT_ITEM2_BACKSTAB_VM_DOWN",
	"ACT_ITEM2_BACKSTAB_VM_IDLE",
	"ACT_MELEE_VM_ITEM2_STUN",
	"ACT_ITEM3_VM_DRAW",
	"ACT_ITEM3_VM_HOLSTER",
	"ACT_ITEM3_VM_IDLE",
	"ACT_ITEM3_VM_PULLBACK",
	"ACT_ITEM3_VM_PRIMARYATTACK",
	"ACT_ITEM3_VM_SECONDARYATTACK",
	"ACT_ITEM3_VM_RELOAD",
	"ACT_ITEM3_VM_DRYFIRE",
	"ACT_ITEM3_VM_IDLE_TO_LOWERED",
	"ACT_ITEM3_VM_IDLE_LOWERED",
	"ACT_ITEM3_VM_LOWERED_TO_IDLE",
	"ACT_ITEM3_VM_CHARGE",
	"ACT_ITEM3_VM_IDLE_2",
	"ACT_ITEM3_VM_IDLE_3",
	"ACT_ITEM3_VM_CHARGE_IDLE_3",
	"ACT_ITEM3_VM_HITCENTER",
	"ACT_ITEM3_VM_SWINGHARD",
	"ACT_SECONDARY2_VM_DRAW",
	"ACT_SECONDARY2_VM_HOLSTER",
	"ACT_SECONDARY2_VM_IDLE",
	"ACT_SECONDARY2_VM_PULLBACK",
	"ACT_SECONDARY2_VM_PRIMARYATTACK",
	"ACT_SECONDARY2_VM_SECONDARY2ATTACK",
	"ACT_SECONDARY2_VM_RELOAD",
	"ACT_SECONDARY2_RELOAD_START",
	"ACT_SECONDARY2_RELOAD_FINISH",
	"ACT_SECONDARY2_VM_RELOAD2",
	"ACT_SECONDARY2_VM_DRYFIRE",
	"ACT_SECONDARY2_VM_IDLE_TO_LOWERED",
	"ACT_SECONDARY2_VM_IDLE_LOWERED",
	"ACT_SECONDARY2_VM_LOWERED_TO_IDLE",
	"ACT_BACKSTAB_VM_UP",
	"ACT_BACKSTAB_VM_DOWN",
	"ACT_BACKSTAB_VM_IDLE",
	"ACT_PRIMARY_ATTACK_STAND_PREFIRE",
	"ACT_PRIMARY_ATTACK_STAND_POSTFIRE",
	"ACT_PRIMARY_ATTACK_STAND_STARTFIRE",
	"ACT_PRIMARY_ATTACK_CROUCH_PREFIRE",
	"ACT_PRIMARY_ATTACK_CROUCH_POSTFIRE",
	"ACT_PRIMARY_ATTACK_SWIM_PREFIRE",
	"ACT_PRIMARY_ATTACK_SWIM_POSTFIRE",
	"ACT_SECONDARY_ATTACK_STAND_PREFIRE",
	"ACT_SECONDARY_ATTACK_STAND_POSTFIRE",
	"ACT_SECONDARY_ATTACK_STAND_STARTFIRE",
	"ACT_SECONDARY_ATTACK_CROUCH_PREFIRE",
	"ACT_SECONDARY_ATTACK_CROUCH_POSTFIRE",
	"ACT_SECONDARY_ATTACK_SWIM_PREFIRE",
	"ACT_SECONDARY_ATTACK_SWIM_POSTFIRE",
	"ACT_MELEE_ATTACK_STAND_PREFIRE",
	"ACT_MELEE_ATTACK_STAND_POSTFIRE",
	"ACT_MELEE_ATTACK_STAND_STARTFIRE",
	"ACT_MELEE_ATTACK_CROUCH_PREFIRE",
	"ACT_MELEE_ATTACK_CROUCH_POSTFIRE",
	"ACT_MELEE_ATTACK_SWIM_PREFIRE",
	"ACT_MELEE_ATTACK_SWIM_POSTFIRE",
	"ACT_ITEM1_ATTACK_STAND_PREFIRE",
	"ACT_ITEM1_ATTACK_STAND_POSTFIRE",
	"ACT_ITEM1_ATTACK_STAND_STARTFIRE",
	"ACT_ITEM1_ATTACK_CROUCH_PREFIRE",
	"ACT_ITEM1_ATTACK_CROUCH_POSTFIRE",
	"ACT_ITEM1_ATTACK_SWIM_PREFIRE",
	"ACT_ITEM1_ATTACK_SWIM_POSTFIRE",
	"ACT_ITEM2_ATTACK_STAND_PREFIRE",
	"ACT_ITEM2_ATTACK_STAND_POSTFIRE",
	"ACT_ITEM2_ATTACK_STAND_STARTFIRE",
	"ACT_ITEM2_ATTACK_CROUCH_PREFIRE",
	"ACT_ITEM2_ATTACK_CROUCH_POSTFIRE",
	"ACT_ITEM2_ATTACK_SWIM_PREFIRE",
	"ACT_ITEM2_ATTACK_SWIM_POSTFIRE",
	"ACT_MP_STAND_MELEE_ALLCLASS",
	"ACT_MP_CROUCH_MELEE_ALLCLASS",
	"ACT_MP_RUN_MELEE_ALLCLASS",
	"ACT_MP_WALK_MELEE_ALLCLASS",
	"ACT_MP_AIRWALK_MELEE_ALLCLASS",
	"ACT_MP_CROUCHWALK_MELEE_ALLCLASS",
	"ACT_MP_JUMP_MELEE_ALLCLASS",
	"ACT_MP_JUMP_START_MELEE_ALLCLASS",
	"ACT_MP_JUMP_FLOAT_MELEE_ALLCLASS",
	"ACT_MP_JUMP_LAND_MELEE_ALLCLASS",
	"ACT_MP_SWIM_MELEE_ALLCLASS",
	"ACT_MP_ATTACK_STAND_MELEE_ALLCLASS",
	"ACT_MP_ATTACK_STAND_MELEE_SECONDARY_ALLCLASS",
	"ACT_MP_ATTACK_CROUCH_MELEE_ALLCLASS",
	"ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY_ALLCLASS",
	"ACT_MP_ATTACK_SWIM_MELEE_ALLCLASS",
	"ACT_MP_ATTACK_AIRWALK_MELEE_ALLCLASS",
	"ACT_MELEE_ALLCLASS_VM_DRAW",
	"ACT_MELEE_ALLCLASS_VM_HOLSTER",
	"ACT_MELEE_ALLCLASS_VM_IDLE",
	"ACT_MELEE_ALLCLASS_VM_PULLBACK",
	"ACT_MELEE_ALLCLASS_VM_PRIMARYATTACK",
	"ACT_MELEE_ALLCLASS_VM_SECONDARYATTACK",
	"ACT_MELEE_ALLCLASS_VM_RELOAD",
	"ACT_MELEE_ALLCLASS_VM_DRYFIRE",
	"ACT_MELEE_ALLCLASS_VM_IDLE_TO_LOWERED",
	"ACT_MELEE_ALLCLASS_VM_IDLE_LOWERED",
	"ACT_MELEE_ALLCLASS_VM_LOWERED_TO_IDLE",
	"ACT_MELEE_ALLCLASS_VM_STUN",
	"ACT_MELEE_ALLCLASS_VM_HITCENTER",
	"ACT_MELEE_ALLCLASS_VM_SWINGHARD",
	"ACT_MP_STAND_BOMB",
	"ACT_MP_JUMP_START_BOMB",
	"ACT_MP_JUMP_FLOAT_BOMB",
	"ACT_MP_JUMP_LAND_BOMB",
	"ACT_MP_RUN_BOMB",
	"ACT_MP_SWIM_BOMB",
	"ACT_VM_DRAW_QRL",
	"ACT_VM_IDLE_QRL",
	"ACT_VM_PULLBACK_QRL",
	"ACT_VM_PRIMARYATTACK_QRL",
	"ACT_VM_RELOAD_QRL",
	"ACT_VM_RELOAD_START_QRL",
	"ACT_VM_RELOAD_FINISH_QRL",
	"ACT_VM_SHOOTLAST",
	"ACT_VM_PRIMARYATTACK_MIDEMPTY",
	"ACT_VM_SHOOTLAST_IRONSIGHTED",
	"ACT_VM_PRIMARYATTACK_MIDEMPTY_IRONSIGHTED",
	"ACT_VM_RELOADEMPTY",
	"ACT_VM_RELOADMIDEMPTY",
	"ACT_VM_IDLE_MIDEMPTY",
	"ACT_VM_SPRINT_MIDEMPTY",
	"ACT_VM_WALK_MIDEMPTY",
	"ACT_VM_IDLE_LOWERED_EMPTY",
	"ACT_VM_IDLE_WALK_EMPTY",
	"ACT_VM_IDLE_SPRINT_EMPTY",
	"ACT_VM_IDLE_WALL_EMPTY",
	"ACT_VM_IDLE_IS_EMPTY",
	"ACT_MP_RELOAD_STAND_PRIMARY3",
	"ACT_MP_RELOAD_CROUCH_PRIMARY3",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY3",
	"ACT_MP_RELOAD_STAND_PRIMARY3_LOOP",
	"ACT_MP_RELOAD_CROUCH_PRIMARY3_LOOP",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY3_LOOP",
	"ACT_MP_RELOAD_STAND_PRIMARY3_END",
	"ACT_MP_RELOAD_CROUCH_PRIMARY3_END",
	"ACT_MP_RELOAD_AIRWALK_PRIMARY3_END",
	"ACT_MP_RELOAD_SWIM_PRIMARY3",
	"ACT_MP_THROW",
	"ACT_THROWABLE_VM_DRAW",
	"ACT_THROWABLE_VM_IDLE",
	"ACT_THROWABLE_VM_FIRE",
	"ACT_SPELL_VM_DRAW",
	"ACT_SPELL_VM_IDLE",
	"ACT_SPELL_VM_ARM",
	"ACT_SPELL_VM_FIRE",
	"LAST_SHARED_ACTIVITY"
};

Activity FindAct(const char *ptr)
{
	for (int i = 0; i < ACTIVITY_SIZE; i++)
	{	
		if (Q_strcmp(ptr, ActivityMappedList[i]) != 0)
			continue;
		else
			return (Activity)i;
	}
	return (Activity)0;
}

WeaponType FindType(const char *ptr)
{
	for (int i = 0; i < WEAPONTYPE_SIZE; i++)
	{
		if (Q_strcmp(ptr, WeaponTypeMappedList[i]) != 0)
			continue;
		else
			return (WeaponType)i;
	}
	return (WeaponType)0;
}

// The sound categories found in the weapon classname.txt files
// This needs to match the WeaponSound_t enum in weapon_parse.h
#if !defined(_STATIC_LINKED) || defined(CLIENT_DLL)
const char *pWeaponSoundCategories[ NUM_SHOOT_SOUND_TYPES ] = 
{
	"empty",
	"single_shot",
	"single_shot_npc",
	"double_shot",
	"double_shot_npc",
	"burst",
	"reload",
	"reload_npc",
	"melee_miss",
	"melee_hit",
	"melee_hit_world",
	"special1",
	"special2",
	"special3",
	"taunt",
	"deploy",
	"low_ammo"
};
#else
extern const char *pWeaponSoundCategories[ NUM_SHOOT_SOUND_TYPES ];
#endif

void StringToFloatArray(float *pVector, int count, const char *pString)
{
	char *pstr, *pfront, tempString[128];
	int	j;

	Q_strncpy(tempString, pString, sizeof(tempString));
	pstr = pfront = tempString;

	for (j = 0; j < count; j++)			// lifted from pr_edict.c
	{
		pVector[j] = atof(pfront);

		// skip any leading whitespace
		while (*pstr && *pstr <= ' ')
			pstr++;

		// skip to next whitespace
		while (*pstr && *pstr > ' ')
			pstr++;

		if (!*pstr)
			break;

		pstr++;
		pfront = pstr;
	}
}
void StringToIntArray(CUtlVector<int> *pVector, const char *pString, const char *separator)
{
	CUtlVector<char*, CUtlMemory<char*> > arr;

	Q_SplitString(pString, separator, arr);

	pVector->RemoveAll();

	for (int i = 0; i < arr.Count(); i++)
	{
		int k = atoi(arr.Element(i));
		pVector->AddToTail(k);
	}
}

int GetWeaponSoundFromString( const char *pszString )
{
	for ( int i = EMPTY; i < NUM_SHOOT_SOUND_TYPES; i++ )
	{
		if ( !Q_stricmp(pszString,pWeaponSoundCategories[i]) )
			return (WeaponSound_t)i;
	}
	return -1;
}


// Item flags that we parse out of the file.
typedef struct
{
	const char *m_pFlagName;
	int m_iFlagValue;
} itemFlags_t;
#if !defined(_STATIC_LINKED) || defined(CLIENT_DLL)
itemFlags_t g_ItemFlags[8] =
{
	{ "ITEM_FLAG_SELECTONEMPTY",	ITEM_FLAG_SELECTONEMPTY },
	{ "ITEM_FLAG_NOAUTORELOAD",		ITEM_FLAG_NOAUTORELOAD },
	{ "ITEM_FLAG_NOAUTOSWITCHEMPTY", ITEM_FLAG_NOAUTOSWITCHEMPTY },
	{ "ITEM_FLAG_LIMITINWORLD",		ITEM_FLAG_LIMITINWORLD },
	{ "ITEM_FLAG_EXHAUSTIBLE",		ITEM_FLAG_EXHAUSTIBLE },
	{ "ITEM_FLAG_DOHITLOCATIONDMG", ITEM_FLAG_DOHITLOCATIONDMG },
	{ "ITEM_FLAG_NOAMMOPICKUPS",	ITEM_FLAG_NOAMMOPICKUPS },
	{ "ITEM_FLAG_NOITEMPICKUP",		ITEM_FLAG_NOITEMPICKUP }
};
#else
extern itemFlags_t g_ItemFlags[7];
#endif


static CUtlDict< FileWeaponInfo_t*, unsigned short > m_WeaponInfoDatabase;

#ifdef _DEBUG
// used to track whether or not two weapons have been mistakenly assigned the wrong slot
bool g_bUsedWeaponSlots[MAX_WEAPON_SLOTS][MAX_WEAPON_POSITIONS] = { 0 };

#endif

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *name - 
// Output : FileWeaponInfo_t
//-----------------------------------------------------------------------------
static WEAPON_FILE_INFO_HANDLE FindWeaponInfoSlot( const char *name )
{
	// Complain about duplicately defined metaclass names...
	unsigned short lookup = m_WeaponInfoDatabase.Find( name );
	if ( lookup != m_WeaponInfoDatabase.InvalidIndex() )
	{
		return lookup;
	}

	FileWeaponInfo_t *insert = CreateWeaponInfo();

	lookup = m_WeaponInfoDatabase.Insert( name, insert );
	Assert( lookup != m_WeaponInfoDatabase.InvalidIndex() );
	return lookup;
}

// Find a weapon slot, assuming the weapon's data has already been loaded.
WEAPON_FILE_INFO_HANDLE LookupWeaponInfoSlot( const char *name )
{
	return m_WeaponInfoDatabase.Find( name );
}



// FIXME, handle differently?
static FileWeaponInfo_t gNullWeaponInfo;


//-----------------------------------------------------------------------------
// Purpose: 
// Input  : handle - 
// Output : FileWeaponInfo_t
//-----------------------------------------------------------------------------
FileWeaponInfo_t *GetFileWeaponInfoFromHandle( WEAPON_FILE_INFO_HANDLE handle )
{
	if ( handle < 0 || handle >= m_WeaponInfoDatabase.Count() )
	{
		return &gNullWeaponInfo;
	}

	if ( handle == m_WeaponInfoDatabase.InvalidIndex() )
	{
		return &gNullWeaponInfo;
	}

	return m_WeaponInfoDatabase[ handle ];
}

//-----------------------------------------------------------------------------
// Purpose: 
// Output : WEAPON_FILE_INFO_HANDLE
//-----------------------------------------------------------------------------
WEAPON_FILE_INFO_HANDLE GetInvalidWeaponInfoHandle( void )
{
	return (WEAPON_FILE_INFO_HANDLE)m_WeaponInfoDatabase.InvalidIndex();
}

#if 0
void ResetFileWeaponInfoDatabase( void )
{
	int c = m_WeaponInfoDatabase.Count(); 
	for ( int i = 0; i < c; ++i )
	{
		delete m_WeaponInfoDatabase[ i ];
	}
	m_WeaponInfoDatabase.RemoveAll();

#ifdef _DEBUG
	memset(g_bUsedWeaponSlots, 0, sizeof(g_bUsedWeaponSlots));
#endif
}
#endif

void PrecacheFileWeaponInfoDatabase( IFileSystem *filesystem, const unsigned char *pICEKey )
{
	if ( m_WeaponInfoDatabase.Count() )
		return;

	char path[_MAX_PATH];
	Q_snprintf(path, sizeof(path), "scripts/%s/weapon_manifest.txt", (cvar->FindVar("oc_weapons_scripts_preset")->GetString()));

	KeyValues *manifest = new KeyValues( "weaponscripts" );
	if (manifest->LoadFromFile(filesystem, path, "GAME"))//"scripts/weapons/weapon_manifest.txt"
	{
		for ( KeyValues *sub = manifest->GetFirstSubKey(); sub != NULL ; sub = sub->GetNextKey() )
		{
			if ( !Q_stricmp( sub->GetName(), "file" ) )
			{
				char fileBase[512];
				Q_FileBase( sub->GetString(), fileBase, sizeof(fileBase) );
				WEAPON_FILE_INFO_HANDLE tmp;
#ifdef CLIENT_DLL
				if ( ReadWeaponDataFromFileForSlot( filesystem, fileBase, &tmp, pICEKey ) )
				{
					gWR.LoadWeaponSprites( tmp );
				}
#else
				ReadWeaponDataFromFileForSlot( filesystem, fileBase, &tmp, pICEKey );
#endif
			}
			else
			{
				Error( "Expecting 'file', got %s\n", sub->GetName() );
			}
		}
	}
	manifest->deleteThis();
	
}

KeyValues* ReadEncryptedKVFile( IFileSystem *filesystem, const char *szFilenameWithoutExtension, const unsigned char *pICEKey, bool bForceReadEncryptedFile /*= false*/ )
{
	Assert( strchr( szFilenameWithoutExtension, '.' ) == NULL );
	char szFullName[512];

	const char *pSearchPath = "MOD";

	if ( pICEKey == NULL )
	{
		pSearchPath = "GAME";
	}

	// Open the weapon data file, and abort if we can't
	KeyValues *pKV = new KeyValues( "WeaponDatafile" );

	Q_snprintf(szFullName,sizeof(szFullName), "%s.txt", szFilenameWithoutExtension);

	if ( bForceReadEncryptedFile || !pKV->LoadFromFile( filesystem, szFullName, pSearchPath ) ) // try to load the normal .txt file first
	{
#ifndef _XBOX
		if ( pICEKey )
		{
			Q_snprintf(szFullName,sizeof(szFullName), "%s.ctx", szFilenameWithoutExtension); // fall back to the .ctx file

			FileHandle_t f = filesystem->Open( szFullName, "rb", pSearchPath );

			if (!f)
			{
				pKV->deleteThis();
				return NULL;
			}
			// load file into a null-terminated buffer
			int fileSize = filesystem->Size(f);
			char *buffer = (char*)MemAllocScratch(fileSize + 1);
		
			Assert(buffer);
		
			filesystem->Read(buffer, fileSize, f); // read into local buffer
			buffer[fileSize] = 0; // null terminate file as EOF
			filesystem->Close( f );	// close file after reading

			UTIL_DecodeICE( (unsigned char*)buffer, fileSize, pICEKey );

			bool retOK = pKV->LoadFromBuffer( szFullName, buffer, filesystem );

			MemFreeScratch();

			if ( !retOK )
			{
				pKV->deleteThis();
				return NULL;
			}
		}
		else
		{
			pKV->deleteThis();
			return NULL;
		}
#else
		pKV->deleteThis();
		return NULL;
#endif
	}

	return pKV;
}


/*const char * WeapPathManifests[]
{
	{"scripts/weapons/weapon_manifest.txt"},
	{ "scripts/weapons/custom/weapon_manifest.txt" }
};
#define NUM_MANIFESTS	(ARRAYSIZE(WeapPathManifests))*/

//-----------------------------------------------------------------------------
// Purpose: Read data on weapon from script file
// Output:  true  - if data2 successfully read
//			false - if data load fails
//-----------------------------------------------------------------------------

bool ReadWeaponDataFromFileForSlot( IFileSystem* filesystem, const char *szWeaponName, WEAPON_FILE_INFO_HANDLE *phandle, const unsigned char *pICEKey )
{
	if ( !phandle )
	{
		Assert( 0 );
		return false;
	}
	
	*phandle = FindWeaponInfoSlot( szWeaponName );
	FileWeaponInfo_t *pFileInfo = GetFileWeaponInfoFromHandle( *phandle );
	Assert( pFileInfo );

	/*if ( pFileInfo->bParsedScript )
		return true;*/

	char sz[128];
	Q_snprintf( sz, sizeof( sz ), "scripts/%s/%s", cvar->FindVar("oc_weapons_scripts_preset")->GetString(), szWeaponName );//"scripts/weapons/%s"

	KeyValues *pKV = ReadEncryptedKVFile( filesystem, sz, pICEKey,
#if defined( DOD_DLL )
		true			// Only read .ctx files!
#else
		false
#endif
		);

	if (!pKV)
	{
		char szC[128];
		Q_snprintf(szC, sizeof(szC), "scripts/%s/custom/%s", cvar->FindVar("oc_weapons_scripts_preset")->GetString(), szWeaponName);//"scripts/weapons/custom/%s"

		pKV = ReadEncryptedKVFile(filesystem, szC, pICEKey,
#if defined( DOD_DLL )
			true			// Only read .ctx files!
#else
			false
#endif
			);
	}

	if ( !pKV )
		return false;

	pFileInfo->Parse( pKV, szWeaponName );

	pKV->deleteThis();

	return true;
}


//-----------------------------------------------------------------------------
// FileWeaponInfo_t implementation.
//-----------------------------------------------------------------------------

FileWeaponInfo_t::FileWeaponInfo_t()
{
	bParsedScript = false;
	bLoadedHudElements = false;
	szClassName[0] = 0;
	szPrintName[0] = 0;

	szViewModel[0] = 0;
	//szAdditionalViewModel[0] = 0;
	szWorldModel[0] = 0;
	szAnimationPrefix[0] = 0;
	iSlot = 0;
	iPosition = 0;
	iMaxClip1 = 0;
	iMaxClip2 = 0;
	minScopeFov = 0; //  FOV  //OverCharged
	maxScopeFov = 0; //  FOV  //OverCharged

	iDefaultClip1 = 0;
	iDefaultClip2 = 0;

	iFlashLifeTime;//OverCharged
	iFlashType = 0;//OverCharged
//	iFlashLightType = 0;//OverCharged
//	iFlashLightTypeNPC = 0;//OverCharged

	iWeight = 0;
	iRumbleEffect = -1;
	bAutoSwitchTo = false;
	bAutoSwitchFrom = false;
	iFlags = 0;
	szAmmo1[0] = 0;
	szAmmo2[0] = 0;
	memset( aShootSounds, 0, sizeof( aShootSounds ) );
	iAmmoType = 0;
	iAmmo2Type = 0;
	m_bMeleeWeapon = false;
	iSpriteCount = 0;
	iconActive = 0;
	iconInactive = 0;
	iconAmmo = 0;
	iconAmmo2 = 0;
	iconCrosshair = 0;
	iconAutoaim = 0;
	iconZoomedCrosshair = 0;
	iconZoomedAutoaim = 0;
	bShowUsageHint = false;
	m_bAllowFlipping = true;
	m_bBuiltRightHanded = true;
}

#ifdef CLIENT_DLL
extern ConVar hud_fastswitch;
#endif

void FileWeaponInfo_t::ParseCustomData(KeyValues *pKeyValuesData, const char *szWeaponName)
{
	/*Q_strncpy(MuzzleAttachment, pKeyValuesData->GetString("MuzzleAttachment", "muzzle"), MAX_WEAPON_STRING);
	Q_strncpy(MuzzleAttachment2, pKeyValuesData->GetString("MuzzleAttachment2", "muzzle1"), MAX_WEAPON_STRING);
	Q_strncpy(MuzzleAttachmentNPC, pKeyValuesData->GetString("MuzzleAttachmentNPC", "muzzle"), MAX_WEAPON_STRING);*/

	m_bCanBePickedUpByNPCs = pKeyValuesData->GetBool("NPCAllowPickup", true);

	m_bLowAmmoNotify = pKeyValuesData->GetBool("LowAmmoNotify", true);

	//bool hasSecondaryAmmo = pKeyValuesData->GetInt("clip2_size", WEAPON_NOCLIP) > 0 || pKeyValuesData->GetInt("default_clip2", iMaxClip2) > 0;
	m_bUsePrimaryAmmoAsSecondary = pKeyValuesData->GetBool("UsePrimaryAmmoAsSecondary", false);

	m_bPickHint = false;
	Q_strncpy(hintText, pKeyValuesData->GetString("PickupHint"), MAX_WEAPON_STRING);
	if (hintText)
		m_bPickHint = true;

	viewmodel_fov = pKeyValuesData->GetInt("viewmodel_fov", 0);

	ViewModelShake = true;

	bool bulletInfo = false;

	KeyValues *aP = pKeyValuesData->FindKey("Attachments_Properties");
	if (aP)
	{
		KeyValues *pPlr = aP->FindKey("Player");
		if (pPlr)
		{
			Q_strncpy(MuzzleAttachment, pPlr->GetString("MuzzleAttachment", "muzzle"), MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachment2, pPlr->GetString("MuzzleSecondAttachment", "muzzle1"), MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachmentSilencer, pPlr->GetString("MuzzleSilencerAttachment", "muzzle_sil"), MAX_WEAPON_STRING);
		}
		else
		{
			Q_strncpy(MuzzleAttachment, "muzzle", MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachment2, "muzzle1", MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachmentSilencer, "muzzle_sil", MAX_WEAPON_STRING);
		}

		KeyValues *pNpc = aP->FindKey("NPC");
		if (pNpc)
		{
			Q_strncpy(MuzzleAttachmentNPC, pNpc->GetString("MuzzleAttachmentNPC", "muzzle"), MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachmentNPC2, pNpc->GetString("MuzzleSecondAttachmentNPC", "muzzle1"), MAX_WEAPON_STRING);
		}
		else
		{
			Q_strncpy(MuzzleAttachmentNPC, "muzzle", MAX_WEAPON_STRING);
			Q_strncpy(MuzzleAttachmentNPC2, "muzzle1", MAX_WEAPON_STRING);
		}
	}
	else
	{
		Q_strncpy(MuzzleAttachment, "muzzle", MAX_WEAPON_STRING);
		Q_strncpy(MuzzleAttachment2, "muzzle1", MAX_WEAPON_STRING);
		Q_strncpy(MuzzleAttachmentSilencer, "muzzle_sil", MAX_WEAPON_STRING);
		Q_strncpy(MuzzleAttachmentNPC, "muzzle", MAX_WEAPON_STRING);
		Q_strncpy(MuzzleAttachmentNPC2, "muzzle1", MAX_WEAPON_STRING);
	}

	KeyValues *bP = pKeyValuesData->FindKey("Bullet_Properties");
	if (bP)
	{
		bulletInfo = true;
		bulletPenetrationLength = bP->GetFloat("PenetrationLength", 5.f);
		BulletImpulseForce = bP->GetFloat("ImpulseForce", 1500.f);
		BulletSpeed = bP->GetFloat("Speed", 81.5f);
	}
	else
	{
		bulletInfo = false;
		BulletSpeed = 81.5f;
		bulletPenetrationLength = 5.f;
		BulletImpulseForce = 1500.f;
	}

	BulletOverride = bulletInfo;

	KeyValues *pShell = pKeyValuesData->FindKey("Weapon_shells");
	if (pShell)
	{
		Q_strncpy(iWeaponShellAttachment, pShell->GetString("Shell_Attachment", "muzzle"), sizeof(iWeaponShellAttachment));

		iWeaponShellModel = AllocPooledString(pShell->GetString("ShellModel", "models/weapons/shell.mdl"));
		iWeaponShellBounceSound = AllocPooledString(pShell->GetString("ShellBounceSound", "Bounce.Shell"));
		iWeaponShellHitSound = AllocPooledString(pShell->GetString("ShellBounceSound", "Bounce.Shell"));
		iWeaponShellParticle = AllocPooledString(pShell->GetString("ShellParticle", "None"));

		const char *pShellName = pShell->GetString("ShellModel", "models/weapons/shell.mdl");
		CBaseEntity::PrecacheModel(pShellName);

		const char *pShellSndName = pShell->GetString("ShellBounceSound", "Bounce.Shell");
		CBaseEntity::PrecacheScriptSound(pShellSndName);

		iWeaponShellExhaustAttachment = AllocPooledString(pShell->GetString("ShellExhaustAttachment", "None"));
		iWeaponShellExhaustAttachmentDual1 = AllocPooledString(pShell->GetString("ShellExhaustAttachment1", "None"));
		iWeaponShellExhaustAttachmentDual2 = AllocPooledString(pShell->GetString("ShellExhaustAttachment2", "None"));
		iWeaponShellExhaustParticle = AllocPooledString(pShell->GetString("ShellExhaustParticle", "None"));

		if (!FStrEq(STRING(iWeaponShellParticle), "None"))
			PrecacheParticleSystem(pShell->GetString("ShellParticle", "None"));

		if (!FStrEq(STRING(iWeaponShellExhaustParticle), "None"))
			PrecacheParticleSystem(pShell->GetString("ShellExhaustParticle", "None"));

		DevMsg("Weapon_shells\n");
	}
	else
	{
		Q_strncpy(iWeaponShellAttachment, "muzzle", sizeof(iWeaponShellAttachment));
		iWeaponShellModel = AllocPooledString("models/weapons/shell.mdl");
		iWeaponShellBounceSound = AllocPooledString("Bounce.Shell");
		iWeaponShellHitSound = AllocPooledString("Bounce.Shell");
		iWeaponShellParticle = AllocPooledString("None");
		iWeaponShellExhaustParticle = AllocPooledString("None");
	}

	KeyValues *pSpread = pKeyValuesData->FindKey("Weapon_spread");
	if (pSpread)
	{
		KeyValues *pPlr = pSpread->FindKey("Player");
		if (pPlr)
		{
			ScopeSightSpread = pPlr->GetFloat("ScopeSight_spread", 1.f) / 1000;
			irSightSpread = pPlr->GetFloat("IronSight_spread", 1.f) / 1000;
			standingSpread = pPlr->GetFloat("Standing_spread", 2.f) / 1000;
			crouchSpread = pPlr->GetFloat("Crouch_spread", 0.5f) / 1000;
			walkingSpread = pPlr->GetFloat("Walking_spread", 3.f) / 1000;
			runningSpread = pPlr->GetFloat("Running_spread", 5.f) / 1000;
		}
		else
		{
			ScopeSightSpread = 1.f / 1000;
			irSightSpread = 1.f / 1000;
			standingSpread = 2.f / 1000;
			crouchSpread = 0.5f / 1000;
			walkingSpread = 3.f / 1000;
			runningSpread = 5.f / 1000;
		}

		KeyValues *pNpc = pSpread->FindKey("NPC");
		if (pNpc)
		{
			standingSpreadNpc = pNpc->GetFloat("Standing_spread", 1.f) / 1000;
			crouchSpreadNpc = pNpc->GetFloat("Crouch_spread", 0.5f) / 1000;
			walkingSpreadNpc = pNpc->GetFloat("Walking_spread", 2.f) / 1000;
			runningSpreadNpc = pNpc->GetFloat("Running_spread", 5.f) / 1000;
		}
		else
		{
			standingSpreadNpc = 1.f / 1000;
			crouchSpreadNpc = 0.5f / 1000;
			walkingSpreadNpc = 2.f / 1000;
			runningSpreadNpc = 5.f / 1000;
		}
	}
	else
	{
		ScopeSightSpread = 1.f / 1000;
		irSightSpread = 1.f / 1000;
		standingSpread = 2.f / 1000;
		crouchSpread = 0.5f / 1000;
		walkingSpread = 3.f / 1000;
		runningSpread = 5.f / 1000;

		standingSpreadNpc = 1.f / 1000;
		crouchSpreadNpc = 0.5f / 1000;
		walkingSpreadNpc = 2.f / 1000;
		runningSpreadNpc = 5.f / 1000;
	}


	KeyValues *Recoil = pKeyValuesData->FindKey("Weapon_Recoil");
	if (Recoil)
	{
		KeyValues *RecoilOld = Recoil->FindKey("Default_Kick");
		if (RecoilOld)
		{
			useHl2KickSystem = true;
			easyDampen = RecoilOld->GetFloat("easy_dampen", 0);
			maxVerticalKick = RecoilOld->GetFloat("max_vertical_kick", 0);
			slideLimit = RecoilOld->GetFloat("slide_limit", 0);
		}
		else
		{
			useHl2KickSystem = false;
		}

		recoilVelocity = Recoil->GetInt("velocity", 0);

		ironOrScopeKoefficient = Recoil->GetFloat("IronScopeDecreaseKoefficient", 0.5f);

		DoRandomPunch = Recoil->GetInt("DoRandomPunch", 0);
		AutoReduce = Recoil->GetInt("AutoReduce", 0);
		ViewPunch_X = Recoil->GetFloat("ViewPunch_X", 0);
		ViewPunch_Y = Recoil->GetFloat("ViewPunch_Y", 0);
		ViewPunch_Z = Recoil->GetFloat("ViewPunch_Z", 0);

		DoRandomKick = Recoil->GetInt("DoRandomKick", 0);
		ViewKick_X = Recoil->GetFloat("ViewKick_X", 0);
		ViewKick_Y = Recoil->GetFloat("ViewKick_Y", 0);
		ViewKick_Z = Recoil->GetFloat("ViewKick_Z", 0);
	}
	else
	{
		recoilVelocity = 0.f;
		ironOrScopeKoefficient = 0.5f;
		DoRandomPunch = 0;
		AutoReduce = 0;
		ViewPunch_X = 0.0f;
		ViewPunch_Y = 0.0f;
		ViewPunch_Z = 0.0f;

		DoRandomKick = 0;
		ViewKick_X = 0.0f;
		ViewKick_Y = 0.0f;
		ViewKick_Z = 0.0f;
	}

	KeyValues *PP = pKeyValuesData->FindKey("Particles_Properties");
	if (PP)
	{
		KeyValues *kPlayer = PP->FindKey("Player");
		if (kPlayer)
		{
			iAttachment = kPlayer->GetInt("Attachment", 1);

			iAttachment_second = MAKE_STRING(kPlayer->GetString("Attachment_Secondary", "muzzle1"));

			iAttachment_sil = MAKE_STRING(kPlayer->GetString("Attachment_Silencer", "muzzle_sil"));

			KeyValues *tracers = kPlayer->FindKey("Muzzle_Tracers");
			if (tracers)
			{
				for (int i = 0; i < 80; i++)
				{
					iMuzzleTracerType[i] = MAKE_STRING("None");
				}

				char muzzleTracer[256];
				for (indexT = 0;; indexT++)
				{
					Q_snprintf(muzzleTracer, sizeof(muzzleTracer), "MuzzleTracer%i", indexT + 1);

					if (tracers->GetString(muzzleTracer, "") == NULL || AllocPooledString(tracers->GetString(muzzleTracer, "")) == AllocPooledString(""))
					{
						break;
					}

					externalIndexT = indexT;

					iMuzzleTracerType[indexT] = AllocPooledString(tracers->GetString(muzzleTracer, ""));

					if (Q_strlen(muzzleTracer) > 0)
					{
						char parsedData[256];
						Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleTracerType[indexT]));

						//if (!FStrEq(parsedData, ""))
						PrecacheParticleSystem(parsedData);
					}
				}

				TracersCombined = tracers->GetBool("tracer_combined", false);

				//const char *ccOldMuzzleTracerType = tracers->GetString("OldMuzzleTracer", "effects/spark");
				//iOldMuzzleTracerType = MAKE_STRING(ccOldMuzzleTracerType);

				Q_strncpy(iOldMuzzleTracerType, tracers->GetString("OldMuzzleTracer", "effects/spark"), MAX_WEAPON_STRING);

				PrecacheMaterial(iOldMuzzleTracerType);

				CBaseEntity::PrecacheModel(iOldMuzzleTracerType);

				iOldMuzzleTracerLengthMin = tracers->GetFloat("OldMuzzleTracerLengthMin", 250.f);
				iOldMuzzleTracerLengthMax = tracers->GetFloat("OldMuzzleTracerLengthMax", 500.f);
				iOldMuzzleTracerScaleMin = tracers->GetFloat("OldMuzzleTracerScaleMin", 3.f);
				iOldMuzzleTracerScaleMax = tracers->GetFloat("OldMuzzleTracerScaleMax", 5.f);
				iOldMuzzleTracerVelocityMin = tracers->GetFloat("OldMuzzleTracerVelocityMin", 5000.f);
				iOldMuzzleTracerVelocityMax = tracers->GetFloat("OldMuzzleTracerVelocityMax", 6000.f);
				iOldMuzzleTracerWhiz = tracers->GetBool("OldMuzzleTracerWhiz", false);


			}
			else
			{
				externalIndexT = 0;
				iMuzzleTracerType[0] = AllocPooledString("NULL");
				Q_strncpy(iOldMuzzleTracerType, "effects/spark", MAX_WEAPON_STRING);
				//iOldMuzzleTracerType = AllocPooledString("effects/spark");
				TracersCombined = false;
				iOldMuzzleTracerLengthMin = 250.f;
				iOldMuzzleTracerLengthMax = 500.f;
				iOldMuzzleTracerScaleMin = 3.f;
				iOldMuzzleTracerScaleMax = 5.f;
				iOldMuzzleTracerVelocityMin = 5000.f;
				iOldMuzzleTracerVelocityMax = 6000.f;
				iOldMuzzleTracerWhiz = false;
			}

			KeyValues *particles = kPlayer->FindKey("Muzzle_Particles");
			if (particles)
			{
				/*iMuzzleFlashTransparentType = AllocPooledString(particles->GetString("MuzzleFlashTransparent", "None"));
				if (!FStrEq(STRING(iMuzzleFlashTransparentType), "None"))
				{
					PrecacheParticleSystem(particles->GetString("MuzzleFlashTransparent", ""));
				}*/
				DevMsg("Muzzle_Particles\n");

				iMuzzleFlashUnderWaterType = AllocPooledString(particles->GetString("MuzzleFlashUnderWater", "None"));
				if (!FStrEq(STRING(iMuzzleFlashUnderWaterType), "None"))
				{
					PrecacheParticleSystem(particles->GetString("MuzzleFlashUnderWater", ""));
				}

				iMuzzleFlashShortBurst = AllocPooledString(particles->GetString("MuzzleFlashShortBurst", "None"));
				if (!FStrEq(STRING(iMuzzleFlashShortBurst), "None"))
				{
					PrecacheParticleSystem(particles->GetString("MuzzleFlashShortBurst", ""));
				}

				iMuzzleSmoke = AllocPooledString(particles->GetString("MuzzleSmoke", "None"));
				if (!FStrEq(STRING(iMuzzleSmoke), "None"))
				{
					PrecacheParticleSystem(particles->GetString("MuzzleSmoke", ""));

					iMuzzleSmokeNumShots = particles->GetInt("ShotsBeforeSmoke", 0);
				}
				else
					iMuzzleSmokeNumShots = 0;

				char muzzleFlash[256];
				for (index = 0;; index++)
				{
					Q_snprintf(muzzleFlash, sizeof(muzzleFlash), "MuzzleFlash%i", index + 1);//0+1

					if (particles->GetString(muzzleFlash, "") == NULL || AllocPooledString(particles->GetString(muzzleFlash, "")) == AllocPooledString(""))
					{
						break;
					}

					externalIndex = index;

					iMuzzleFlashType[index] = AllocPooledString(particles->GetString(muzzleFlash, ""));

					if (Q_strlen(muzzleFlash) > 0)
					{
						char parsedData[256];
						Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleFlashType[index]));
						PrecacheParticleSystem(parsedData);
					}
				}
				oldFlashType = particles->GetInt("OldMuzzleFlashType", 2);
				//oldFlashTypeTP = particles->GetBool("OldMuzzleFlashTypeTPStyle", false);
				oldFlashTypeTP = particles->GetBool("OldMuzzleFlashFirstPerson", true);

				KeyValues *particlesSec = particles->FindKey("Muzzle_Particles_Secondary");
				if (particlesSec)
				{
					char muzzleFlashS[256];
					for (indexS = 0;; indexS++)
					{
						Q_snprintf(muzzleFlashS, sizeof(muzzleFlashS), "MuzzleFlashSecondary%i", indexS + 1);

						if (particlesSec->GetString(muzzleFlashS, "") == NULL || AllocPooledString(particlesSec->GetString(muzzleFlashS, "")) == AllocPooledString(""))
						{
							break;
						}

						externalIndexS = indexS;

						iMuzzleFlashTypeS[indexS] = AllocPooledString(particlesSec->GetString(muzzleFlashS, "None"));


						if (Q_strlen(muzzleFlashS) > 0)
						{
							char parsedData[256];
							Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleFlashTypeS[indexS]));
							PrecacheParticleSystem(parsedData);
						}

					}

					iMuzzleFlashDelayed = AllocPooledString(particlesSec->GetString("MuzzleFlashDelayed", "None"));
					if (!FStrEq(STRING(iMuzzleFlashDelayed), "None"))
					{
						PrecacheParticleSystem(particlesSec->GetString("MuzzleFlashDelayed", "None"));
					}

					//iSecondaryAttachment = AllocPooledString(particlesSec->GetString("Attachment", "Muzzle"));

					Q_strncpy(iSecondaryAttachment, particlesSec->GetString("Attachment", "Muzzle"), MAX_WEAPON_STRING);
				}
				else
				{
					indexS = 0;
					externalIndexS = indexS;
					char iMuzzleFlashTypeInterceptorS[MAX_WEAPON_STRING];
					Q_strncpy(iMuzzleFlashTypeInterceptorS, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
					iMuzzleFlashTypeS[indexS] = AllocPooledString(iMuzzleFlashTypeInterceptorS);
					iMuzzleFlashDelayed = AllocPooledString("");
					//iSecondaryAttachment = AllocPooledString("Muzzle");
					Q_strncpy(iSecondaryAttachment, "Muzzle", MAX_WEAPON_STRING);
				}
			}
			else
			{
				index = 0;
				externalIndex = index;
				char iMuzzleFlashTypeInterceptor[MAX_WEAPON_STRING];
				Q_strncpy(iMuzzleFlashTypeInterceptor, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
				iMuzzleFlashType[index] = AllocPooledString(iMuzzleFlashTypeInterceptor);
				oldFlashType = 2;
				oldFlashTypeTP = true;// false;

				indexS = 0;
				externalIndexS = indexS;
				char iMuzzleFlashTypeInterceptorS[MAX_WEAPON_STRING];
				Q_strncpy(iMuzzleFlashTypeInterceptorS, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
				iMuzzleFlashTypeS[indexS] = AllocPooledString(iMuzzleFlashTypeInterceptorS);
				iMuzzleFlashDelayed = AllocPooledString("");
				//iSecondaryAttachment = AllocPooledString("Muzzle");
				Q_strncpy(iSecondaryAttachment, "Muzzle", MAX_WEAPON_STRING);

				iMuzzleSmokeNumShots = 0;

				char iMuzzleFlashError[MAX_WEAPON_STRING];
				Q_snprintf(iMuzzleFlashError, sizeof(iMuzzleFlashError), "%s: Error, not enough particles in script file", szWeaponName);
				
				//iMuzzleFlashShortBurst = iMuzzleFlashTransparentType = iMuzzleFlashDelayed = iMuzzleSmoke = AllocPooledString(iMuzzleFlashError);
			}

		}
		else
		{
			externalIndexT = 0;
			iMuzzleTracerType[0] = AllocPooledString("NULL");
			Q_strncpy(iOldMuzzleTracerType, "effects/spark", MAX_WEAPON_STRING);
			//iOldMuzzleTracerType = AllocPooledString("effects/spark");
			TracersCombined = false;
			iOldMuzzleTracerLengthMin = 250.f;
			iOldMuzzleTracerLengthMax = 500.f;
			iOldMuzzleTracerScaleMin = 3.f;
			iOldMuzzleTracerScaleMax = 5.f;
			iOldMuzzleTracerVelocityMin = 5000.f;
			iOldMuzzleTracerVelocityMax = 6000.f;
			iOldMuzzleTracerWhiz = false;

			index = 0;
			externalIndex = index;
			char iMuzzleFlashTypeInterceptor[MAX_WEAPON_STRING];
			Q_strncpy(iMuzzleFlashTypeInterceptor, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
			iMuzzleFlashType[index] = AllocPooledString(iMuzzleFlashTypeInterceptor);
			oldFlashType = 2;
			oldFlashTypeTP = true;// false;

			indexS = 0;
			externalIndexS = indexS;
			char iMuzzleFlashTypeInterceptorS[MAX_WEAPON_STRING];
			Q_strncpy(iMuzzleFlashTypeInterceptorS, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
			iMuzzleFlashTypeS[indexS] = AllocPooledString(iMuzzleFlashTypeInterceptorS);
			iMuzzleFlashDelayed = AllocPooledString("");
			//iSecondaryAttachment = AllocPooledString("Muzzle");
			Q_strncpy(iSecondaryAttachment, "Muzzle", MAX_WEAPON_STRING);
		}

		KeyValues *kNpc = PP->FindKey("Npc");
		if (kNpc)
		{
			KeyValues *tracersNpc = kNpc->FindKey("Muzzle_Tracers");
			if (tracersNpc)
			{
				char muzzleTracerNpc[256];
				for (indexTN = 0;; indexTN++)
				{
					Q_snprintf(muzzleTracerNpc, sizeof(muzzleTracerNpc), "MuzzleTracer%i", indexTN + 1);

					if (tracersNpc->GetString(muzzleTracerNpc, "") == NULL || AllocPooledString(tracersNpc->GetString(muzzleTracerNpc, "")) == AllocPooledString(""))
					{
						break;
					}

					externalIndexTN = indexTN;

					iMuzzleTracerNpcType[indexTN] = AllocPooledString(tracersNpc->GetString(muzzleTracerNpc, ""));

					if (Q_strlen(muzzleTracerNpc) > 0)
					{
						char parsedData[256];
						Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleTracerNpcType[indexTN]));
						PrecacheParticleSystem(parsedData);
					}
				}

				TracersCombinedNpc = tracersNpc->GetBool("tracer_combined", false);

				//const char *ccOldMuzzleTracerTypeNPC = tracersNpc->GetString("OldMuzzleTracer", "effects/spark");
				//iOldMuzzleTracerTypeNPC = MAKE_STRING(ccOldMuzzleTracerTypeNPC);

				Q_strncpy(iOldMuzzleTracerTypeNPC, tracersNpc->GetString("OldMuzzleTracer", "effects/spark"), MAX_WEAPON_STRING);

				PrecacheMaterial(iOldMuzzleTracerTypeNPC);

				CBaseEntity::PrecacheModel(iOldMuzzleTracerTypeNPC);

				iOldMuzzleTracerLengthMinNPC = tracersNpc->GetFloat("OldMuzzleTracerLengthMin", 250.f);
				iOldMuzzleTracerLengthMaxNPC = tracersNpc->GetFloat("OldMuzzleTracerLengthMax", 500.f);
				iOldMuzzleTracerScaleMinNPC = tracersNpc->GetFloat("OldMuzzleTracerScaleMin", 3.f);
				iOldMuzzleTracerScaleMaxNPC = tracersNpc->GetFloat("OldMuzzleTracerScaleMax", 5.f);
				iOldMuzzleTracerVelocityMinNPC = tracersNpc->GetFloat("OldMuzzleTracerVelocityMin", 5000.f);
				iOldMuzzleTracerVelocityMaxNPC = tracersNpc->GetFloat("OldMuzzleTracerVelocityMax", 6000.f);
				iOldMuzzleTracerWhizNPC = tracersNpc->GetBool("OldMuzzleTracerWhiz", true);
			}
			else
			{
				externalIndexTN = 0;
				iMuzzleTracerNpcType[0] = AllocPooledString("NULL");
				Q_strncpy(iOldMuzzleTracerTypeNPC, "effects/spark", MAX_WEAPON_STRING);
				//iOldMuzzleTracerTypeNPC = AllocPooledString("effects/spark");
				TracersCombinedNpc = false;
				iOldMuzzleTracerLengthMinNPC = 250.f;
				iOldMuzzleTracerLengthMaxNPC = 500.f;
				iOldMuzzleTracerScaleMinNPC = 3.f;
				iOldMuzzleTracerScaleMaxNPC = 5.f;
				iOldMuzzleTracerVelocityMinNPC = 5000.f;
				iOldMuzzleTracerVelocityMaxNPC = 6000.f;
				iOldMuzzleTracerWhizNPC = true;
			}

			KeyValues *particlesNpc = kNpc->FindKey("Muzzle_Particles");
			if (particlesNpc)
			{
				iMuzzleFlashUnderWaterTypeNpc = AllocPooledString(particlesNpc->GetString("MuzzleFlashUnderWater", "None"));
				if (particlesNpc->GetString("MuzzleFlashUnderWater", "") != NULL && !FStrEq(particlesNpc->GetString("MuzzleFlashUnderWater", "None"), "None"))
					PrecacheParticleSystem(particlesNpc->GetString("MuzzleFlashUnderWater", "None"));
				else
					iMuzzleFlashUnderWaterTypeNpc = AllocPooledString("None");

				char muzzleFlashNpc[256];
				for (indexNpc = 0;; indexNpc++)
				{
					Q_snprintf(muzzleFlashNpc, sizeof(muzzleFlashNpc), "MuzzleFlash%i", indexNpc + 1);

					if (particlesNpc->GetString(muzzleFlashNpc, "") == NULL || AllocPooledString(particlesNpc->GetString(muzzleFlashNpc, "")) == AllocPooledString(""))
					{
						break;
					}

					externalIndexNpc = indexNpc;

					iMuzzleFlashTypeNpc[indexNpc] = AllocPooledString(particlesNpc->GetString(muzzleFlashNpc, ""));


					if (Q_strlen(muzzleFlashNpc) > 0)
					{
						char parsedData[256];
						Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleFlashTypeNpc[indexNpc]));
						PrecacheParticleSystem(parsedData);
					}
				}
				oldFlashTypeNPC = particlesNpc->GetInt("OldMuzzleFlashType", 2);
			}
			else
			{
				indexNpc = 0;
				externalIndexNpc = indexNpc;
				char iMuzzleFlashTypeInterceptorNpc[MAX_WEAPON_STRING];
				Q_strncpy(iMuzzleFlashTypeInterceptorNpc, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
				iMuzzleFlashTypeNpc[indexNpc] = AllocPooledString(iMuzzleFlashTypeInterceptorNpc);
				oldFlashTypeNPC = 2;
			}
		}
		else
		{
			externalIndexTN = 0;
			iMuzzleTracerNpcType[0] = AllocPooledString("NULL");
			Q_strncpy(iOldMuzzleTracerTypeNPC, "effects/spark", MAX_WEAPON_STRING);
			//iOldMuzzleTracerTypeNPC = AllocPooledString("effects/spark");
			TracersCombinedNpc = false;
			iOldMuzzleTracerLengthMinNPC = 250.f;
			iOldMuzzleTracerLengthMaxNPC = 500.f;
			iOldMuzzleTracerScaleMinNPC = 3.f;
			iOldMuzzleTracerScaleMaxNPC = 5.f;
			iOldMuzzleTracerVelocityMinNPC = 5000.f;
			iOldMuzzleTracerVelocityMaxNPC = 6000.f;
			iOldMuzzleTracerWhizNPC = true;

			indexNpc = 0;
			externalIndexNpc = indexNpc;
			char iMuzzleFlashTypeInterceptorNpc[MAX_WEAPON_STRING];
			Q_strncpy(iMuzzleFlashTypeInterceptorNpc, PP->GetString("MuzzleFlashType"), MAX_WEAPON_STRING);
			iMuzzleFlashTypeNpc[indexNpc] = AllocPooledString(iMuzzleFlashTypeInterceptorNpc);
			oldFlashTypeNPC = 2;
		}
	}
	else
	{
		iAttachment = 1;
		iAttachment_second = MAKE_STRING("muzzle1");
		iAttachment_sil = MAKE_STRING("muzzle_sil");
	}

	KeyValues *dlight = pKeyValuesData->FindKey("MuzzleDLight_Properties");
	if (dlight)
	{
		KeyValues *dlightPlr = dlight->FindKey("Player");
		if (dlightPlr)
		{
			AllowMuzzleFlashDLight = true;
			DLightDisableForPlayer = false;

			iMuzzleFlashLightNoModelIllumination = dlightPlr->GetBool("no_model_Illumination", false);
			iMuzzleFlashLightR = dlightPlr->GetInt("DLightRed", 0);
			iMuzzleFlashLightG = dlightPlr->GetInt("DLightGreen", 0);
			iMuzzleFlashLightB = dlightPlr->GetInt("DLightBlue", 0);
			iMuzzleFlashLightExponent = dlightPlr->GetInt("DLightExponent", 0);
			iMuzzleFlashLightRadius = dlightPlr->GetFloat("DLightRadius", 400.f);
			iMuzzleFlashLightDecayTime = dlightPlr->GetFloat("DLightDecay", 0.2f);
			iMuzzleFlashLightLifeTime = dlightPlr->GetFloat("DLightLifeTime", 1.0f);
			iMuzzleFlashLightAttachment = AllocPooledString(dlightPlr->GetString("DLightAttachment", "muzzle"));
			//iMuzzleFlashLightAttachment = MAKE_STRING(dlightPlr->GetString("DLightAttachment", "muzzle"));
		}
		else
		{
			AllowMuzzleFlashDLight = true;
			DLightDisableForPlayer = false;

			iMuzzleFlashLightNoModelIllumination = dlight->GetBool("no_model_Illumination", false);
			iMuzzleFlashLightR = dlight->GetInt("DLightRed", 0);
			iMuzzleFlashLightG = dlight->GetInt("DLightGreen", 0);
			iMuzzleFlashLightB = dlight->GetInt("DLightBlue", 0);
			iMuzzleFlashLightExponent = dlight->GetInt("DLightExponent", 0);
			iMuzzleFlashLightRadius = dlight->GetFloat("DLightRadius", 400.f);
			iMuzzleFlashLightDecayTime = dlight->GetFloat("DLightDecay", 0.2f);
			iMuzzleFlashLightLifeTime = dlight->GetFloat("DLightLifeTime", 1.0f);
			iMuzzleFlashLightAttachment = AllocPooledString(dlight->GetString("DLightAttachment", "muzzle"));
		}

		if (DLightDisableForPlayer)
			AllowMuzzleFlashDLight = false;

		//DLightDisableForPlayer = dlight->GetBool("disabled_for_player", false);

		KeyValues *dlightNpc = dlight->FindKey("Npc");
		if (dlightNpc)
		{
			AllowMuzzleFlashDLightNpc = true;

			iMuzzleFlashLightNoModelIlluminationNpc = dlightNpc->GetBool("no_model_Illumination", false);
			iMuzzleFlashLightRNpc = dlightNpc->GetInt("DLightRed", 0);
			iMuzzleFlashLightGNpc = dlightNpc->GetInt("DLightGreen", 0);
			iMuzzleFlashLightBNpc = dlightNpc->GetInt("DLightBlue", 0);
			iMuzzleFlashLightExponentNpc = dlightNpc->GetInt("DLightExponent", 0);
			iMuzzleFlashLightRadiusNpc = dlightNpc->GetFloat("DLightRadius", 400.f);
			iMuzzleFlashLightDecayTimeNpc = dlightNpc->GetFloat("DLightDecay", 0.2f);
			iMuzzleFlashLightLifeTimeNpc = dlightNpc->GetFloat("DLightLifeTime", 1.0f);
			iMuzzleFlashLightAttachmentNpc = AllocPooledString(dlightNpc->GetString("DLightAttachment", "muzzle"));
		}
		else
		{
			AllowMuzzleFlashDLightNpc = false;

			iMuzzleFlashLightNoModelIlluminationNpc = iMuzzleFlashLightNoModelIllumination;
			iMuzzleFlashLightRNpc = iMuzzleFlashLightR;
			iMuzzleFlashLightGNpc = iMuzzleFlashLightG;
			iMuzzleFlashLightBNpc = iMuzzleFlashLightB;
			iMuzzleFlashLightExponentNpc = iMuzzleFlashLightExponent;
			iMuzzleFlashLightRadiusNpc = iMuzzleFlashLightRadius;
			iMuzzleFlashLightDecayTimeNpc = iMuzzleFlashLightDecayTime;
			iMuzzleFlashLightLifeTimeNpc = iMuzzleFlashLightLifeTime;
			iMuzzleFlashLightAttachmentNpc = iMuzzleFlashLightAttachment;
		}

	}
	else
	{
		AllowMuzzleFlashDLight = false;
		DLightDisableForPlayer = true;
		iMuzzleFlashLightNoModelIllumination = false;
		iMuzzleFlashLightR = 255;
		iMuzzleFlashLightG = 255;
		iMuzzleFlashLightB = 255;
		iMuzzleFlashLightExponent = 0;
		iMuzzleFlashLightRadius = 400.f;
		iMuzzleFlashLightDecayTime = 0.2f;
		iMuzzleFlashLightLifeTime = 1.0f;
		iMuzzleFlashLightAttachment = AllocPooledString("muzzle");
		//iMuzzleFlashLightAttachment = MAKE_STRING("muzzle");

		AllowMuzzleFlashDLightNpc = false;

		iMuzzleFlashLightNoModelIlluminationNpc = iMuzzleFlashLightNoModelIllumination;
		iMuzzleFlashLightRNpc = iMuzzleFlashLightR;
		iMuzzleFlashLightGNpc = iMuzzleFlashLightG;
		iMuzzleFlashLightBNpc = iMuzzleFlashLightB;
		iMuzzleFlashLightExponentNpc = iMuzzleFlashLightExponent;
		iMuzzleFlashLightRadiusNpc = iMuzzleFlashLightRadius;
		iMuzzleFlashLightDecayTimeNpc = iMuzzleFlashLightDecayTime;
		iMuzzleFlashLightLifeTimeNpc = iMuzzleFlashLightLifeTime;
		iMuzzleFlashLightAttachmentNpc = iMuzzleFlashLightAttachment;
	}

	KeyValues *light = pKeyValuesData->FindKey("MuzzleProjectedLight_Properties");
	if (light)
	{
		AllowProjectedMuzzleFlashes = true;

		Q_strncpy(iFlashFirstAttachment, light->GetString("FirstAttachment", "None"), MAX_WEAPON_STRING);
		Q_strncpy(iFlashSecondAttachment, light->GetString("SecondAttachment", "None"), MAX_WEAPON_STRING);

		iFlashRollPrimary = light->GetBool("RollFlash", iFlashRollPrimary);

		iFlashLifeTime = light->GetFloat("FlashLifeTime", iFlashLifeTime);
		iFlashXPos = light->GetFloat("X", iFlashXPos);
		iFlashYPos = light->GetFloat("Y", iFlashYPos);
		iFlashZPos = light->GetFloat("Z", iFlashZPos);


		char muzzleLight[256];
		for (indexLight = 0;; indexLight++)
		{
			Q_snprintf(muzzleLight, sizeof(muzzleLight), "MuzzleLight%i", indexLight + 1);

			if (light->GetString(muzzleLight, "") == NULL || AllocPooledString(light->GetString(muzzleLight, "")) == AllocPooledString(""))
			{
				break;
			}

			externalIndexLight = indexLight;

			iMuzzleLightType[indexLight] = AllocPooledString(light->GetString(muzzleLight, ""));

			/*if (iMuzzleLightType[indexLight] == AllocPooledString(""))
				allowMuzzleLight = false;
			else
				allowMuzzleLight = true;*/


			char parsedData[256];
			Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleLightType[indexLight]));
			PrecacheMaterial(parsedData);

			CBaseEntity::PrecacheModel(parsedData);

			//PrecacheMaterial(light->GetString(muzzleLight, ""));
		}


		KeyValues *Slight = light->FindKey("SecondaryLight");
		if (Slight)
		{
			iFlashRollSecondary = Slight->GetBool("RollFlash", iFlashRollSecondary);

			char muzzleSLight[256];
			for (indexSLight = 0;; indexSLight++)
			{
				Q_snprintf(muzzleSLight, sizeof(muzzleSLight), "MuzzleSecondaryLight%i", indexSLight + 1);

				if (Slight->GetString(muzzleSLight, "") == NULL || AllocPooledString(Slight->GetString(muzzleSLight, "")) == AllocPooledString(""))
				{
					break;
				}

				externalIndexSLight = indexSLight;

				iMuzzleSecondaryLightType[indexSLight] = AllocPooledString(Slight->GetString(muzzleSLight, ""));

				char parsedData[256];
				Q_snprintf(parsedData, sizeof(parsedData), STRING(iMuzzleSecondaryLightType[indexSLight]));

				PrecacheMaterial(parsedData);

				CBaseEntity::PrecacheModel(parsedData);


				//PrecacheMaterial(Slight->GetString(muzzleSLight, ""));
			}
			iFlashType = 1;
		}
		else
		{
			iFlashRollSecondary = false;
			externalIndexSLight = 0;
			iFlashType = 0;
		}
	}
	else
	{
		AllowProjectedMuzzleFlashes = false;

		Q_strncpy(iFlashFirstAttachment, "muzzle", MAX_WEAPON_STRING);
		Q_strncpy(iFlashSecondAttachment, "muzzle", MAX_WEAPON_STRING);
		iFlashLifeTime = 0.3f;
		iFlashXPos = 0.f;
		iFlashYPos = 0.f;
		iFlashZPos = 0.f;
		externalIndexSLight = 0;
		iFlashType = 0;
		iFlashRollPrimary = true;
		iFlashRollSecondary = false;

		//allowMuzzleLight = false;
		externalIndexLight = 0;
		iMuzzleLightType[0] = AllocPooledString("NULL");
	}

	KeyValues *Attachment = pKeyValuesData->FindKey("CameraFollow_Properties");
	if (Attachment)
	{
		AttachmentApply = true;

		if (AllocPooledString(Attachment->GetString("Attachments")) != AllocPooledString("") && AllocPooledString(Attachment->GetString("Attachments")) != AllocPooledString("None"))
			StringToIntArray(&AttachmentsArray, Attachment->GetString("Attachments"), " ");
			//UTIL_StringToIntUTILVector(&AttachmentsArray, Attachment->GetString("Attachments"));

		if (AllocPooledString(Attachment->GetString("Bones")) != AllocPooledString("") && AllocPooledString(Attachment->GetString("Bones")) != AllocPooledString("None"))
			StringToIntArray(&BonesArray, Attachment->GetString("Bones"), " ");
			//UTIL_StringToIntUTILVector(&BonesArray, Attachment->GetString("Bones"));

		if (AllocPooledString(Attachment->GetString("Scales")) != AllocPooledString("") && AllocPooledString(Attachment->GetString("Scales")) != AllocPooledString("None"))
			UTIL_StringToFloatUTILVector(&Scales, Attachment->GetString("Scales"));

		Randomize = Attachment->GetBool("RandomizeScales", false);
	}
	else
	{
		AttachmentApply = false;

		Randomize = false;
	}

	DevMsg("\n\n%s\n\n", szWeaponName);

	m_bHasMag = false;

	KeyValues *Mag = pKeyValuesData->FindKey("Garbage_Properties");
	if (Mag)
	{
		Q_strncpy(iMagName, Mag->GetString("Garb_Name", "None"), sizeof(iMagName));

		m_bHasMag = !(0 == Q_strcmp(iMagName, "None"));

		if (m_bHasMag)
		{
			CBaseEntity::PrecacheModel(iMagName);

			Q_strncpy(magHitSound, Mag->GetString("Garb_HitSound", "Magazines.Impact1"), sizeof(magHitSound));

			CBaseEntity::PrecacheScriptSound(magHitSound);

			Q_strncpy(Mag_Attachment, Mag->GetString("Garb_Attachment", "muzzle"), sizeof(Mag_Attachment));
			
			Mag_Offset.x = Mag->GetFloat("Garb_Offset_x", 0);
			Mag_Offset.y = Mag->GetFloat("Garb_Offset_y", 0);
			Mag_Offset.z = Mag->GetFloat("Garb_Offset_z", 0);

			Mag_Angle.x = Mag->GetFloat("Garb_Angle_x", 0);
			Mag_Angle.y = Mag->GetFloat("Garb_Angle_y", 0);
			Mag_Angle.z = Mag->GetFloat("Garb_Angle_z", 0);

			Mag_Velocity.x = Mag->GetFloat("Garb_Velocity_x", 0);
			Mag_Velocity.y = Mag->GetFloat("Garb_Velocity_y", 0);
			Mag_Velocity.z = Mag->GetFloat("Garb_Velocity_z", 0);

			Mag_AngularVelocity.x = Mag->GetFloat("Garb_AngularVelocity_x", 0);
			Mag_AngularVelocity.y = Mag->GetFloat("Garb_AngularVelocity_y", 0);
			Mag_AngularVelocity.z = Mag->GetFloat("Garb_AngularVelocity_z", 0);

			//magHitSound = MAKE_STRING(Mag->GetString("HitSound", "Magazines.Impact1"));
		}
	}
	else
	{
		Mag_Offset.x = 0.0f;
		Mag_Offset.y = 0.0f;
		Mag_Offset.z = 0.0f;

		Mag_Angle.x = 0.0f;
		Mag_Angle.y = 0.0f;
		Mag_Angle.z = 0.0f;

		Mag_Velocity.x = 0.0f;
		Mag_Velocity.y = 0.0f;
		Mag_Velocity.z = 0.0f;
		Mag_AngularVelocity.x = 0.0f;
		Mag_AngularVelocity.y = 0.0f;
		Mag_AngularVelocity.z = 0.0f;

		Q_strncpy(magHitSound, "Magazines.Impact1", sizeof(magHitSound));

		CBaseEntity::PrecacheScriptSound(magHitSound);

		Q_strncpy(Mag_Attachment, "muzzle", sizeof(Mag_Attachment));
	}

	// this just saves off the data in the script file for later use
	KeyValues *pEt = pKeyValuesData->FindKey("ViewModel_Properties");
	if (pEt)
	{
		KeyValues *pTP = pEt->FindKey("ThirdPerson");
		if (pTP)
		{
			m_expOffsetTP.x = pTP->GetFloat("pos_x", 0.0f);
			m_expOffsetTP.y = pTP->GetFloat("pos_y", 0.0f);
			m_expOffsetTP.z = pTP->GetFloat("pos_z", 0.0f);

			m_expOriOffsetTP.x = pTP->GetFloat("ang_x", 0.0f);
			m_expOriOffsetTP.y = pTP->GetFloat("ang_y", 0.0f);
			m_expOriOffsetTP.z = pTP->GetFloat("ang_z", 0.0f);
		}
		else
		{
			m_expOffsetTP = vec3_origin;
			m_expOriOffsetTP.Init();
		}

		//      //OverCharged
		m_expOffset.x = pEt->GetFloat("pos_x", 0.0f);
		m_expOffset.y = pEt->GetFloat("pos_y", 0.0f);
		m_expOffset.z = pEt->GetFloat("pos_z", 0.0f);

		m_expOriOffset.x = pEt->GetFloat("ang_x", 0.0f);
		m_expOriOffset.y = pEt->GetFloat("ang_y", 0.0f);
		m_expOriOffset.z = pEt->GetFloat("ang_z", 0.0f);

		// IRONSIGHT//OverCharged
		m_expOffset2.x = pEt->GetFloat("iron_pos_x", 0.0f);
		m_expOffset2.y = pEt->GetFloat("iron_pos_y", 0.0f);
		m_expOffset2.z = pEt->GetFloat("iron_pos_z", 0.0f);

		m_expOriOffset2.x = pEt->GetFloat("iron_ang_x", 0.0f);// 
		m_expOriOffset2.y = pEt->GetFloat("iron_ang_y", 0.0f);
		m_expOriOffset2.z = pEt->GetFloat("iron_ang_z", 0.0f);

		// In Scope//OverCharged
		m_expOffsetScope.x = pEt->GetFloat("scope_pos_x", 0.0f);
		m_expOffsetScope.y = pEt->GetFloat("scope_pos_y", 0.0f);
		m_expOffsetScope.z = pEt->GetFloat("scope_pos_z", 0.0f);

		m_expOriOffsetScope.x = pEt->GetFloat("scope_ang_x", 0.0f);// 
		m_expOriOffsetScope.y = pEt->GetFloat("scope_ang_y", 0.0f);
		m_expOriOffsetScope.z = pEt->GetFloat("scope_ang_z", 0.0f);

		PositionWall.x = pEt->GetFloat("PosW_x", m_expOffset.x);
		PositionWall.y = pEt->GetFloat("PosW_y", m_expOffset.y);
		PositionWall.z = pEt->GetFloat("PosW_z", m_expOffset.z);
		AngleWall.x = pEt->GetFloat("AngleW_x", 0.0f);
		AngleWall.y = pEt->GetFloat("AngleW_y", 0.0f);
		AngleWall.z = pEt->GetFloat("AngleW_z", 0.0f);


		PositionFwd.x = pEt->GetFloat("PosF_x", m_expOffset.x);
		PositionFwd.y = pEt->GetFloat("PosF_y", m_expOffset.y);
		PositionFwd.z = pEt->GetFloat("PosF_z", m_expOffset.z);
		AngleFwd.x = pEt->GetFloat("AngleF_x", 0.0f);
		AngleFwd.y = pEt->GetFloat("AngleF_y", 0.0f);
		AngleFwd.z = pEt->GetFloat("AngleF_z", 0.0f);
		ViewmodelRollFix = pEt->GetInt("ViewmodelRollFix", 0);

		PositionBwd.x = pEt->GetFloat("PosB_x", 0.0f);
		PositionBwd.y = pEt->GetFloat("PosB_y", 0.0f);
		PositionBwd.z = pEt->GetFloat("PosB_z", 0.0f);
		AngleBwd.x = pEt->GetFloat("AngleB_x", 0.0f);
		AngleBwd.y = pEt->GetFloat("AngleB_y", 0.0f);
		AngleBwd.z = pEt->GetFloat("AngleB_z", 0.0f);


		PositionLeft.x = pEt->GetFloat("PosL_x", 0.0f);
		PositionLeft.y = pEt->GetFloat("PosL_y", 0.0f);
		PositionLeft.z = pEt->GetFloat("PosL_z", 0.0f);
		AngleLeft.x = pEt->GetFloat("AngleL_x", 0.0f);
		AngleLeft.y = pEt->GetFloat("AngleL_y", 0.0f);
		AngleLeft.z = pEt->GetFloat("AngleL_z", 0.0f);

		PositionRight.x = pEt->GetFloat("PosR_x", 0.0f);
		PositionRight.y = pEt->GetFloat("PosR_y", 0.0f);
		PositionRight.z = pEt->GetFloat("PosR_z", 0.0f);
		AngleRight.x = pEt->GetFloat("AngleR_x", 0.0f);
		AngleRight.y = pEt->GetFloat("AngleR_y", 0.0f);
		AngleRight.z = pEt->GetFloat("AngleR_z", 0.0f);

		DistanceToWall = pEt->GetFloat("DistanceToWall", 0.0f);

		LaserSightPosition.x = pEt->GetFloat("LaserPos_x", 0.0f);
		LaserSightPosition.y = pEt->GetFloat("LaserPos_y", 0.0f);
		LaserSightPosition.z = pEt->GetFloat("LaserPos_z", 0.0f);

		ProjectilePosition.x = pEt->GetFloat("ProjectilePos_x", 0.0f);
		ProjectilePosition.y = pEt->GetFloat("ProjectilePos_y", 0.0f);
		ProjectilePosition.z = pEt->GetFloat("ProjectilePos_z", 0.0f);

		ParticleTracerPosition.x = pEt->GetFloat("ParticleTracerPos_x", 0.0f);//TracerPos_x
		ParticleTracerPosition.y = pEt->GetFloat("ParticleTracerPos_y", 0.0f);
		ParticleTracerPosition.z = pEt->GetFloat("ParticleTracerPos_z", 0.0f);

		OriginTracerPosition.x = pEt->GetFloat("OriginTracerPos_x", 0.0f);
		OriginTracerPosition.y = pEt->GetFloat("OriginTracerPos_y", 0.0f);
		OriginTracerPosition.z = pEt->GetFloat("OriginTracerPos_z", 0.0f);//TracerPos2_z

		bool particleTracers = cvar->FindVar("oc_particle_tracers")->GetBool();

		ScopeParticleTracerPosition.x = pEt->GetFloat("ScopeParticleTracerPos_x", particleTracers ? ParticleTracerPosition.x : OriginTracerPosition.x);
		ScopeParticleTracerPosition.y = pEt->GetFloat("ScopeParticleTracerPos_y", particleTracers ? ParticleTracerPosition.y : OriginTracerPosition.y);
		ScopeParticleTracerPosition.z = pEt->GetFloat("ScopeParticleTracerPos_z", particleTracers ? ParticleTracerPosition.z : OriginTracerPosition.z);

		IrSightParticleTracerPosition.x = pEt->GetFloat("IrSightParticleTracerPos_x", particleTracers ? ParticleTracerPosition.x : OriginTracerPosition.x);
		IrSightParticleTracerPosition.y = pEt->GetFloat("IrSightParticleTracerPos_y", particleTracers ? ParticleTracerPosition.y : OriginTracerPosition.y);
		IrSightParticleTracerPosition.z = pEt->GetFloat("IrSightParticleTracerPos_z", particleTracers ? ParticleTracerPosition.z : OriginTracerPosition.z);

		ScopeOriginTracerPosition.x = pEt->GetFloat("ScopeOriginTracerPos_x", OriginTracerPosition.x);
		ScopeOriginTracerPosition.y = pEt->GetFloat("ScopeOriginTracerPos_y", OriginTracerPosition.y);
		ScopeOriginTracerPosition.z = pEt->GetFloat("ScopeOriginTracerPos_z", OriginTracerPosition.z);

		IrSightOriginTracerPosition.x = pEt->GetFloat("IrSightOriginTracerPos_x", OriginTracerPosition.x);
		IrSightOriginTracerPosition.y = pEt->GetFloat("IrSightOriginTracerPos_y", OriginTracerPosition.y);
		IrSightOriginTracerPosition.z = pEt->GetFloat("IrSightOriginTracerPos_z", OriginTracerPosition.z);

		flIronsightFOVOffset = pEt->GetFloat("iron_fov", 70.0f);

	}
	else
	{
		m_expOffsetTP = vec3_origin;
		m_expOriOffsetTP.Init();

		m_expOffset = vec3_origin;
		m_expOffset2 = vec3_origin;
		m_expOffsetScope = vec3_origin;

		DistanceToWall = 0;

		LaserSightPosition = vec3_origin;
		ViewmodelRollFix = 0;
		PositionWall = vec3_origin;
		PositionFwd = vec3_origin;
		PositionBwd = vec3_origin;
		PositionLeft = vec3_origin;
		PositionRight = vec3_origin;

		m_expOriOffset.Init();
		m_expOriOffset2.Init();
		m_expOriOffsetScope.Init();
		AngleWall.Init();
		AngleFwd.Init();
		AngleBwd.Init();
		AngleLeft.Init();
		AngleRight.Init();

		ParticleTracerPosition = vec3_origin;
		ProjectilePosition = vec3_origin;
		OriginTracerPosition = vec3_origin;
		IrSightParticleTracerPosition = vec3_origin;
		ScopeParticleTracerPosition = vec3_origin;
		ScopeOriginTracerPosition = vec3_origin;
		IrSightOriginTracerPosition = vec3_origin;
		flIronsightFOVOffset = 70.0f;

	}
	KeyValues *pLdP = pKeyValuesData->FindKey("LaserDot_Properties");
	if (pLdP)
	{
		enableLaser = true;
		useAsSecondaryAttack = pLdP->GetBool("laser_enable_on_altbutton", false);
		Q_strncpy(beamAttachment, pLdP->GetString("Beam_attachment", "None"), MAX_WEAPON_STRING);
		lightBeamColor.r = pLdP->GetInt("LightBeam_color_r", 0);
		lightBeamColor.g = pLdP->GetInt("LightBeam_color_g", 0);
		lightBeamColor.b = pLdP->GetInt("LightBeam_color_b", 0);
		lightBeamColor.a = pLdP->GetInt("LightBeam_color_exponent", 0);
		lightMinRadius = pLdP->GetFloat("Light_min_radius", 0.1f);
		lightMaxRadius = pLdP->GetFloat("Light_max_radius", 0.1f);
		beamWidth = pLdP->GetFloat("Beam_width", 0.1f);
		beamEndWidth = pLdP->GetFloat("Beam_end_width", 0.1f);
		lightDecay = pLdP->GetFloat("Light_decay", 0.1f);
		lightDie = pLdP->GetFloat("Light_die_time", 0.1f);
		Q_strncpy(beamMaterial, pLdP->GetString("Beam_material", "effects/bluelaser1.vmt"), MAX_WEAPON_STRING);
		//if (Q_strcmp(beamMaterial, "None") != 0)
		{
			CBaseEntity::PrecacheModel(beamMaterial);
			PrecacheMaterial(beamMaterial);
		}
		Q_strncpy(beamHaloMaterial, pLdP->GetString("Beam_halo_material", "sprites/light_glow03.vmt"), MAX_WEAPON_STRING);
		{
			CBaseEntity::PrecacheModel(beamHaloMaterial);
			PrecacheMaterial(beamHaloMaterial);
		}

		beamHaloWidth = pLdP->GetFloat("Beam_halo_width", 0.1f);
		beamHaloViewModelWidth = pLdP->GetFloat("Beam_halo_onmodel_width", 0.1f);

		beamLaserPos.x = pLdP->GetFloat("Beam_pos_x", 0.0f);
		beamLaserPos.y = pLdP->GetFloat("Beam_pos_y", 0.0f);
		beamLaserPos.z = pLdP->GetFloat("Beam_pos_z", 0.0f);

		beamLaserAng.x = pLdP->GetFloat("Beam_ang_x", 0.0f);// 
		beamLaserAng.y = pLdP->GetFloat("Beam_ang_y", 0.0f);
		beamLaserAng.z = pLdP->GetFloat("Beam_ang_z", 0.0f);

		beamLength = pLdP->GetFloat("Beam_length", -1.f);
		lightVMMinRadius = pLdP->GetFloat("Light_vm_min_radius", 0.1f);
		lightVMMaxRadius = pLdP->GetFloat("Light_vm_max_radius", 0.1f);

		Q_strncpy(beamOnSound, pLdP->GetString("Beam_sound_on", "None"), MAX_WEAPON_STRING);

		if (Q_strcmp(beamOnSound, "None") != 0)
			CBaseEntity::PrecacheScriptSound(beamOnSound);

		Q_strncpy(beamOffSound, pLdP->GetString("Beam_sound_off", "None"), MAX_WEAPON_STRING);
		if (Q_strcmp(beamOffSound, "None") != 0)
			CBaseEntity::PrecacheScriptSound(beamOffSound);
	}
	else
	{
		enableLaser = false;
		useAsSecondaryAttack = false;
		lightBeamColor.r = 0;
		lightBeamColor.g = 0;
		lightBeamColor.b = 0;
		lightBeamColor.a = 0;
		lightMinRadius = 0;
		lightMaxRadius = 0;
		lightDecay = 0;
		lightDie = 0;
		lightVMMinRadius = 0.f;
		lightVMMaxRadius = 0.f;
		beamLength = -1.f;
		beamHaloWidth = 0.f;
		beamHaloViewModelWidth = 0.f;
		Q_strncpy(beamAttachment, "None", MAX_WEAPON_STRING);
		Q_strncpy(beamMaterial, "None", MAX_WEAPON_STRING);
		Q_strncpy(beamHaloMaterial, "None", MAX_WEAPON_STRING);
		beamLaserPos = vec3_origin;
		beamLaserAng = QAngle(0, 0, 0);
		Q_strncpy(beamOnSound, "None", MAX_WEAPON_STRING);
		Q_strncpy(beamOffSound, "None", MAX_WEAPON_STRING);
	}

	KeyValues *pTD = pKeyValuesData->FindKey("Scope2D_Properties");
	if (pTD)
	{
		twoDScopeTexture = AllocPooledString(pTD->GetString("Texture", "Scope"));
		allowTwoDScope = true;
	}
	else
	{
		twoDScopeTexture = AllocPooledString("Scope");
		allowTwoDScope = false;
	}

	KeyValues *pZP = pKeyValuesData->FindKey("Zoom_Properties");
	if (pZP)
	{
		minScopeFov = pZP->GetInt("min_scope_fov", minScopeFov); //  FOV  //OverCharged
		maxScopeFov = pZP->GetInt("max_scope_fov", maxScopeFov); //  FOV  //OverCharged
		rtFov = pZP->GetInt("render_targets_fov", rtFov); //  FOV  //OverCharged

		const char *colors = pZP->GetString("RT_color", "255 255 255");
		if (colors)
		{
			try
			{
				CUtlVector<int> colorArray;
				StringToIntArray(&colorArray, colors, " ");

				//float colorArray[3];

				/*Vector colorArray;

				StringToFloatArray(colorArray.Base(), 3, colors);*/
				//UTIL_StringToFloatArray(colorArray, 3, colors);

				color24 rt_Color;
				rt_Color.r = colorArray.Element(0);
				rt_Color.g = colorArray.Element(1);
				rt_Color.b = colorArray.Element(2);
				rtColor = rt_Color;
			}
			catch (...)
			{
				color24 rt_Color;
				rt_Color.r = 1;
				rt_Color.g = 1;
				rt_Color.b = 1;
				rtColor = rt_Color;
			}
		}
		else
		{
			color24 rt_Color;
			rt_Color.r = 1;
			rt_Color.g = 1;
			rt_Color.b = 1;
			rtColor = rt_Color;
		}

		Q_strncpy(rtAttachment, pZP->GetString("Scope_attachment", "Scope"), MAX_WEAPON_STRING);
		AllowEnablingLight = pZP->GetInt("allow_enabling_light", 0);
		KeyValues *pLP = pZP->FindKey("Light_properties");
		if (pLP && AllowEnablingLight)
		{
			lightConstant = pLP->GetFloat("light_constant", lightConstant);
			lightFov = pLP->GetFloat("light_fov", lightFov);
			lightFar = pLP->GetFloat("light_far", lightFar);
			lightLinear = pLP->GetFloat("light_linear", lightLinear);
		}
		else
		{
			lightConstant = 0;
			lightFov = 0;
			lightFar = 0;
			lightLinear = 0;
		}
		AllowEnablingIronsightLight = pZP->GetInt("allow_enabling_ironsight_light", 0);
		KeyValues *pISLP = pZP->FindKey("IronSight_light_properties");
		if (pISLP && AllowEnablingIronsightLight)
		{
			ironlightConstant = pISLP->GetFloat("Iron_light_constant", ironlightConstant);
			ironlightFov = pISLP->GetFloat("Iron_light_fov", ironlightFov);
			ironlightFar = pISLP->GetFloat("Iron_light_far", ironlightFar);
			ironlightLinear = pISLP->GetFloat("Iron_light_linear", ironlightLinear);
		}
		else
		{
			ironlightConstant = 0;
			ironlightFov = 0;
			ironlightFar = 0;
			ironlightLinear = 0;
		}

		iWeaponZoomUpSound = AllocPooledString(pZP->GetString("ZoomSound", "None"));
		if (iWeaponZoomUpSound != AllocPooledString("None"))
			CBaseEntity::PrecacheScriptSound(pZP->GetString("ZoomSound", ""));


		RT_Offset.x = pZP->GetFloat("RT_Offset_x", 0.0f);
		RT_Offset.y = pZP->GetFloat("RT_Offset_y", 0.0f);
		RT_Offset.z = pZP->GetFloat("RT_Offset_z", 0.0f);
		RT_OffsetIron.x = pZP->GetFloat("RT_OffsetIron_x", 0.0f);
		RT_OffsetIron.y = pZP->GetFloat("RT_OffsetIron_y", 0.0f);
		RT_OffsetIron.z = pZP->GetFloat("RT_OffsetIron_z", 0.0f);

		RT_Angle.x = pZP->GetFloat("RT_Angle_x", 0.0f);
		RT_Angle.y = pZP->GetFloat("RT_Angle_y", 0.0f);
		RT_Angle.z = pZP->GetFloat("RT_Angle_z", 0.0f);
		RT_AngleIron.x = pZP->GetFloat("RT_AngleIron_x", 0.0f);
		RT_AngleIron.y = pZP->GetFloat("RT_AngleIron_y", 0.0f);
		RT_AngleIron.z = pZP->GetFloat("RT_AngleIron_z", 0.0f);
	}
	else
	{
		iWeaponZoomUpSound = AllocPooledString("None");
		minScopeFov = 50;
		maxScopeFov = 90;
		rtFov = minScopeFov;

		color24 rt_Color;
		rt_Color.r = 1;
		rt_Color.g = 1;
		rt_Color.b = 1;
		rtColor = rt_Color;

		Q_strncpy(rtAttachment, "Scope", MAX_WEAPON_STRING);
		AllowEnablingLight = 0;
		AllowEnablingIronsightLight = 0;
		lightConstant = 0;
		lightFov = 0;
		lightFar = 0;
		lightLinear = 0;
		ironlightConstant = 0;
		ironlightFov = 0;
		ironlightFar = 0;
		ironlightLinear = 0;

		RT_Offset = vec3_origin;
		RT_OffsetIron = vec3_origin;
		RT_Angle.x = 0.0f;
		RT_Angle.y = 0.0f;
		RT_Angle.z = 0.0f;
		RT_AngleIron.x = 0.0f;
		RT_AngleIron.y = 0.0f;
		RT_AngleIron.z = 0.0f;
	}
	
	bool trueFirstPerson = (cvar->FindVar("oc_player_draw_body")->GetInt() && cvar->FindVar("oc_player_true_firstperson_vm")->GetInt());
	bool oldAnimProp = false;
	KeyValues *pAP = pKeyValuesData->FindKey("Animation_Properties");
	if (pAP)
	{
		ViewModelShake = pAP->GetBool("Shake", true);
		if (!trueFirstPerson)
		{
			oldAnimProp = true;
			animData[0] = SetumAnimations(pAP);
			animData[3] = animData[2] = animData[1] = animData[0];
		}
		else
		{
			KeyValues *pATP = pAP->FindKey("ThirdPerson");
			if (pATP)
			{
				oldAnimProp = true;
				animData[0] = SetumAnimations(pATP);
				animData[3] = animData[2] = animData[1] = animData[0];
			}
		}
	}

	KeyValues *pWFM = pKeyValuesData->FindKey("Weapon_firing_modes");
	if (pWFM)
	{
		bool commonAnims = false;

		KeyValues *pCAP = pWFM->FindKey("Animation_Properties");
		if (pCAP && !oldAnimProp)
		{
			ViewModelShake = pAP->GetBool("Shake", true);

			if (!trueFirstPerson)
			{
				commonAnims = true;
				animData[0] = SetumAnimations(pCAP);
				animData[3] = animData[2] = animData[1] = animData[0];
			}
			else
			{
				KeyValues *pCATP = pCAP->FindKey("ThirdPerson");
				if (pCATP)
				{
					commonAnims = true;
					animData[0] = SetumAnimations(pCATP);
					animData[3] = animData[2] = animData[1] = animData[0];
				}
			}
		}

		if (AllocPooledString(pWFM->GetString("weapon_modes")) != AllocPooledString("") && AllocPooledString(pWFM->GetString("weapon_modes")) != AllocPooledString("None"))
		{
			//WeaponModes.RemoveAll();
			//UTIL_StringToIntUTILVector(&WeaponModes, pWFM->GetString("weapon_modes"));
			/*CUtlVector<char*, CUtlMemory<char*> > arr;

			Q_SplitString(pWFM->GetString("weapon_modes"), " ", arr);

			for (int i = 0; i < arr.Count(); i++)
			{
				int k = atoi(arr.Element(i));
				WeaponModes.AddToTail(k);
			}*/

			StringToIntArray(&WeaponModes, pWFM->GetString("weapon_modes"), " ");
		}

		weaponType = FindType(pWFM->GetString("weapon_type", "None"));

		WeaponDefaultMode = pWFM->GetInt("WeaponDefaultMode", 0);
		NumShots = pWFM->GetInt("NumShots", 0);

		SwingHitTime = pWFM->GetFloat("SwingHitTime", 0.7f);

		SwingHitTime = Clamp(SwingHitTime, 0.f, 1.f);

		SwingDamage = pWFM->GetFloat("SwingDamage", 20.f);

		bool canFireUW = (weaponType == TYPE_MELEE || weaponType == TYPE_GRENADE || weaponType == TYPE_PISTOL || weaponType == TYPE_DUAL_PISTOLS) ? true : false;

		m_bFiresUnderwater = pWFM->GetBool("FiresUnderWater", canFireUW);
		m_bAltFiresUnderwater = pWFM->GetBool("AltFiresUnderWater", canFireUW);

		KeyValues *ammo = pWFM->FindKey("ammo");
		if (ammo)
		{
			ammoRegenDelay = ammo->GetFloat("regeneration_delay", 0.5f);
			ammoRemoveDelay = ammo->GetFloat("remove_delay", 0.5f);
			ammoEmptyDelay = ammo->GetFloat("empty_delay", 1.0f);

			if (ammoRegenDelay && ammoRemoveDelay)
				allowAmmoRegen = true;
		}
		else
		{
			ammoRegenDelay = 0.5f;
			ammoRemoveDelay = 0.5f;
			ammoEmptyDelay = 1.0f;
			allowAmmoRegen = false;
		}

		KeyValues *pS = pWFM->FindKey("Silencer");
		if (pS)
		{
			WeaponUsingSilencer = pS->GetBool("weapon_using_silencer", false);
			Q_strncpy(silencerBodyGroup, pS->GetString("silencer_bodygroup", "silencer"), MAX_WEAPON_STRING);
			silencerBGEnableValue = pS->GetInt("silencer_bodygroup_enable_value", 1);
			silencerBGDisableValue = pS->GetInt("silencer_bodygroup_disable_value", 0);
		}
		else
		{
			WeaponUsingSilencer = false;
			Q_strncpy(silencerBodyGroup, "silencer", MAX_WEAPON_STRING);
			silencerBGEnableValue = 1;
			silencerBGDisableValue = 0;
		}

		KeyValues *pP0 = pWFM->FindKey("weapon_mode:1");
		if (pP0)
		{
			KeyValues *animProp = pP0->FindKey("Animation_Properties");
			if (animProp && !commonAnims && !oldAnimProp)
			{
				if (!trueFirstPerson)
				{
					animData[1] = SetumAnimations(animProp);
					animData[0] = animData[1];
				}
				else
				{
					KeyValues *pCATP = animProp->FindKey("ThirdPerson");
					if (pCATP)
					{
						animData[1] = SetumAnimations(pCATP);
						animData[0] = animData[1];
					}
				}
			}

			mode_fire_rate_single = pP0->GetFloat("mode_fire_rate_single", 0);
			mode_accuracy_maximum_penalty_time = pP0->GetFloat("mode_accuracy_maximum_penalty_time", 0);
			mode_fastest_refire_time = pP0->GetFloat("mode_fastest_refire_time", 0);
			mode_accuracy_shot_penalty_time = pP0->GetFloat("mode_accuracy_shot_penalty_time", 0);
			mode_fastest_dry_refire_time = pP0->GetFloat("mode_fastest_dry_refire_time", 0);
			Q_strncpy(WeaponSwitchingMode1Sound, pP0->GetString("weapon_switching_sound", "None"), MAX_WEAPON_STRING);
			CBaseEntity::PrecacheScriptSound(pP0->GetString("weapon_switching_sound"));
		}
		else
		{
			if (!commonAnims && !oldAnimProp)
				animData[1] = animData[0];

			/*if (!commonAnimsTP && !oldAnimPropTP)
				animDataTP[1] = animDataTP[0];*/

			mode_fire_rate_single = 0.f;
			mode_accuracy_maximum_penalty_time = 0.f;
			mode_fastest_refire_time = 0.f;
			mode_accuracy_shot_penalty_time = 0.f;
			mode_fastest_dry_refire_time = 0.f;
			Q_strncpy(WeaponSwitchingMode1Sound, "None", MAX_WEAPON_STRING);
		}

		KeyValues *pP2 = pWFM->FindKey("weapon_mode:2");//AUTO
		if (pP2)
		{
			KeyValues *animProp = pP2->FindKey("Animation_Properties");
			if (animProp && !commonAnims && !oldAnimProp)
			{
				if (!trueFirstPerson)
				{
					animData[2] = SetumAnimations(animProp);
				}
				else
				{
					KeyValues *animPropTP = animProp->FindKey("ThirdPerson");
					if (animPropTP)
					{
						animData[2] = SetumAnimations(animPropTP);
					}
				}
			}

			if (weaponType == TYPE_BEAM)
				mode_fire_rate_automatic_startup_delay = pP2->GetFloat("startup_delay", 0.f);
			else
				mode_fire_rate_automatic_startup_delay = 0.0f;

			mode_fire_rate_automatic = pP2->GetFloat("mode_fire_rate_automatic", 0);
			AllowShotgunSecondaryAttack = pP2->GetBool("CanDoubleShoot", false);
			Q_strncpy(WeaponSwitchingMode2Sound, pP2->GetString("weapon_switching_sound", "None"), MAX_WEAPON_STRING);
			CBaseEntity::PrecacheScriptSound(pP2->GetString("weapon_switching_sound"));
		}
		else
		{
			if (!commonAnims && !oldAnimProp)
				animData[2] = animData[0];

			/*if (!commonAnimsTP && !oldAnimPropTP)
				animDataTP[2] = animDataTP[0];*/
			AllowShotgunSecondaryAttack = false;

			mode_fire_rate_automatic_startup_delay = 0.0f;
			mode_fire_rate_automatic = 0.f;
			Q_strncpy(WeaponSwitchingMode2Sound, "None", MAX_WEAPON_STRING);
		}
		KeyValues *pP1 = pWFM->FindKey("weapon_mode:3");//BURST
		if (pP1)
		{
			KeyValues *animProp = pP1->FindKey("Animation_Properties");
			if (animProp && !commonAnims && !oldAnimProp)
			{
				if (!trueFirstPerson)
				{
					animData[3] = SetumAnimations(animProp);
				}
				else
				{
					KeyValues *animPropTP = animProp->FindKey("ThirdPerson");
					if (animPropTP)
					{
						animData[3] = SetumAnimations(animPropTP);
					}
				}
			}

			mode_fire_rate_burst = pP1->GetFloat("mode_fire_rate_burst", 0);
			mode_fire_rate_burst_refire_time = pP1->GetFloat("mode_fire_rate_burst_refire_time", 0);
			mode_fire_burst_count = pP1->GetInt("mode_fire_burst_count", 3);
			if (mode_fire_burst_count > 6)
			{
				mode_fire_burst_count = 6;
				DevMsg("Warning: current weapon burst count defined larger than 5");
			}
			Q_strncpy(WeaponSwitchingMode3Sound, pP1->GetString("weapon_switching_sound", "None"), MAX_WEAPON_STRING);
			CBaseEntity::PrecacheScriptSound(pP1->GetString("weapon_switching_sound"));
		}
		else
		{
			if (!commonAnims && !oldAnimProp)
				animData[3] = animData[0];

			/*if (!commonAnimsTP && !oldAnimPropTP)
				animDataTP[3] = animDataTP[0];*/

			mode_fire_rate_burst = 0.f;
			mode_fire_rate_burst_refire_time = 0.f;
			mode_fire_burst_count = 3;
			Q_strncpy(WeaponSwitchingMode3Sound, "None", MAX_WEAPON_STRING);
		}

		KeyValues *pNpc = pWFM->FindKey("NPC");
		if (pNpc)
		{
			npcMinBurst = pNpc->GetInt("MinBurst", 3);
			npcMaxBurst = pNpc->GetInt("MaxBurst", 5);
		}
		else
		{
			npcMinBurst = 3;
			npcMaxBurst = 5;
		}
	}
	else
	{
		if (!pAP && !oldAnimProp)
		{
			animData[0] = SetumAnimations();
			animData[3] = animData[2] = animData[1] = animData[0];
		}

		/*if (!pAP && !oldAnimPropTP)
		{
			animDataTP[0] = SetumAnimations();
			animDataTP[3] = animDataTP[2] = animDataTP[1] = animDataTP[0];
		}*/


		ammoRegenDelay = 0.5f;
		ammoRemoveDelay = 0.5f;
		allowAmmoRegen = false;
		WeaponDefaultMode = 0;
		SwingHitTime = 0;//0.5f
		SwingDamage = 20.f;
		NumShots = 1;
		weaponType = FindType(pKeyValuesData->GetString("weapon_type", "None"));
		m_bFiresUnderwater = false;
		m_bAltFiresUnderwater = false;
		Q_strncpy(WeaponSwitchingMode1Sound, "None", MAX_WEAPON_STRING);
		Q_strncpy(WeaponSwitchingMode2Sound, "None", MAX_WEAPON_STRING);
		Q_strncpy(WeaponSwitchingMode3Sound, "None", MAX_WEAPON_STRING);
		mode_accuracy_maximum_penalty_time = 0.f;
		mode_fastest_refire_time = 0.f;
		mode_accuracy_shot_penalty_time = 0.f;
		mode_fastest_dry_refire_time = 0.f;
		mode_fire_rate_burst = 0.f;
		mode_fire_rate_burst_refire_time = 0.f;
		mode_fire_burst_count = 3;
		mode_fire_rate_automatic_startup_delay = 0.0f;
		mode_fire_rate_automatic = 0.f;
		mode_fire_rate_single = 0.f;

		npcMinBurst = 3;
		npcMaxBurst = 5;
	}
	fireRate = pKeyValuesData->GetFloat("GetFireRate", 0.08f);
	meleeRange = pKeyValuesData->GetFloat("GetRange", 80);
	meleeHull = pKeyValuesData->GetFloat("GetHull", 9);
}

AnimationData FileWeaponInfo_t::SetumAnimations(KeyValues *kv)
{
	AnimationData animData;
	if (kv)
	{
		animData.UseSpecialAnimations = kv->GetBool("UseSpecialAnimations", false);
		animData.UseIronSightAnimations = kv->GetBool("UseIronSightAnimations", false);
		animData.UseHalfFullMagAnimations = kv->GetBool("UseHalfFullMagAnimations", false);
		animData.ReloadWaitWhileAnimation = kv->GetBool("ReloadWaitWhileAnimation", false);
		animData.UsePistolRefireChecker = kv->GetBool("UsePistolRefireChecker", false);
		animData.FirstDrawAnimation = FindAct(kv->GetString("FirstDrawAnimation", "None"));
		animData.DryFireAnimation = FindAct(kv->GetString("DryFireAnimation", "None"));
		//animData.DrawTwoRounds = FindAct(kv->GetString("DrawTwoRounds", "None"));
		animData.DrawAnimation = FindAct(kv->GetString("DrawAnimation", "None"));
		animData.DrawSilencedAnimation = FindAct(kv->GetString("DrawSilencedAnimation", "None"));
		animData.DrawEmptyAnimation = FindAct(kv->GetString("DrawEmptyAnimation", "None"));
		animData.DrawEmptySilencedAnimation = FindAct(kv->GetString("DrawEmptySilencedAnimation", "None"));
		animData.ZeroIdleAnim = kv->GetBool("ZeroIdleAnim", false);
		animData.CustomIdleAnimOnIronSightOrScope = FindAct(kv->GetString("CustomIdleAnimOnIronSightOrScope", "None"));
		animData.ThrowPullUp = FindAct(kv->GetString("ThrowPullUp", "None"));
		animData.ThrowPullDown = FindAct(kv->GetString("ThrowPullDown", "None"));
		animData.ThrowPrimary = FindAct(kv->GetString("ThrowPrimary", "None"));
		animData.ThrowSecondary = FindAct(kv->GetString("ThrowSecondary", "None"));
		animData.IronsightIdle = FindAct(kv->GetString("IronsightIdle", "None"));
		//animData.IdleTwoRounds = FindAct(kv->GetString("IdleTwoRounds", "None"));
		animData.IdleAlmostEmpty = FindAct(kv->GetString("IdleAlmostEmpty", "None"));
		animData.IdleFullEmpty = FindAct(kv->GetString("IdleFullEmpty", "None"));
		animData.IdleAnimation = FindAct(kv->GetString("IdleAnimation", "None"));
		//animData.WallTwoRounds = FindAct(kv->GetString("WallTwoRounds", "None"));
		animData.WallAlmostEmpty = FindAct(kv->GetString("WallAlmostEmpty", "None"));
		animData.WallFullEmpty = FindAct(kv->GetString("WallFullEmpty", "None"));
		//animData.RunTwoRounds = FindAct(kv->GetString("RunTwoRounds", "None"));
		animData.RunAlmostEmpty = FindAct(kv->GetString("RunAlmostEmpty", "None"));
		animData.RunFullEmpty = FindAct(kv->GetString("RunFullEmpty", "None"));
		//animData.WalkTwoRounds = FindAct(kv->GetString("WalkTwoRounds", "None"));
		animData.WalkAlmostEmpty = FindAct(kv->GetString("WalkAlmostEmpty", "None"));
		animData.WalkFullEmpty = FindAct(kv->GetString("WalkFullEmpty", "None"));
		//animData.IronTwoRounds = FindAct(kv->GetString("IronTwoRounds", "None"));
		animData.IronAlmostEmpty = FindAct(kv->GetString("IronAlmostEmpty", "None"));
		animData.IronFullEmpty = FindAct(kv->GetString("IronFullEmpty", "None"));
		//animData.LoweredTwoRounds = FindAct(kv->GetString("LoweredTwoRounds", "None"));
		animData.LoweredAlmostEmpty = FindAct(kv->GetString("LoweredAlmostEmpty", "None"));
		animData.LoweredFullEmpty = FindAct(kv->GetString("LoweredFullEmpty", "None"));
		animData.LoweredAnimation = FindAct(kv->GetString("LoweredAnimation", "None"));
		//animData.HolsterTwoRounds = FindAct(kv->GetString("HolsterTwoRounds", "None"));
		animData.HolsterAlmostEmpty = FindAct(kv->GetString("HolsterAlmostEmpty", "None"));
		animData.HolsterFullEmpty = FindAct(kv->GetString("HolsterFullEmpty", "None"));
		animData.FirePrimaryTwoRounds = FindAct(kv->GetString("FirePrimaryTwoRounds", "None"));
		animData.FirePrimaryAlmostEmpty = FindAct(kv->GetString("FirePrimaryAlmostEmpty", "None"));
		animData.FirePrimaryCompleteEmpty = FindAct(kv->GetString("FirePrimaryCompleteEmpty", "None"));
		animData.FireIronsightedTwoRounds = FindAct(kv->GetString("FireIronsightedTwoRounds", "None"));
		animData.FireIronsightedAlmostEmpty = FindAct(kv->GetString("FireIronsightedAlmostEmpty", "None"));
		animData.FireIronsightedCompleteEmpty = FindAct(kv->GetString("FireIronsightedCompleteEmpty", "None"));
		animData.FireScopedTwoRounds = FindAct(kv->GetString("FireScopedTwoRounds", "None"));
		animData.FireScopedAlmostEmpty = FindAct(kv->GetString("FireScopedAlmostEmpty", "None"));
		animData.FireScopedCompleteEmpty = FindAct(kv->GetString("FireScopedCompleteEmpty", "None"));
		animData.FirePrimary1 = FindAct(kv->GetString("FirePrimary1", "None"));
		animData.FirePrimary2 = FindAct(kv->GetString("FirePrimary2", "None"));
		animData.FirePrimary3 = FindAct(kv->GetString("FirePrimary3", "None"));
		animData.FirePrimary4 = FindAct(kv->GetString("FirePrimary4", "None"));
		animData.FirePrimarySilenced1 = FindAct(kv->GetString("FirePrimarySilenced1", "None"));
		animData.FirePrimarySilenced2 = FindAct(kv->GetString("FirePrimarySilenced2", "None"));
		animData.FirePrimarySilenced3 = FindAct(kv->GetString("FirePrimarySilenced3", "None"));
		animData.FirePrimarySilenced4 = FindAct(kv->GetString("FirePrimarySilenced4", "None"));
		animData.FirePrimarySpecial = FindAct(kv->GetString("FirePrimarySpecial", "None"));
		animData.FireIronsighted1 = FindAct(kv->GetString("FireIronsighted1", "None"));
		animData.FireIronsighted2 = FindAct(kv->GetString("FireIronsighted2", "None"));
		animData.FireIronsighted3 = FindAct(kv->GetString("FireIronsighted3", "None"));
		animData.FireIronsighted4 = FindAct(kv->GetString("FireIronsighted4", "None"));
		animData.FireIronsightedSilenced1 = FindAct(kv->GetString("FireIronsightedSilenced1", "None"));
		animData.FireIronsightedSilenced2 = FindAct(kv->GetString("FireIronsightedSilenced2", "None"));
		animData.FireIronsightedSilenced3 = FindAct(kv->GetString("FireIronsightedSilenced3", "None"));
		animData.FireIronsightedSilenced4 = FindAct(kv->GetString("FireIronsightedSilenced4", "None"));
		animData.FireScoped1 = FindAct(kv->GetString("FireScoped1", "None"));
		animData.FireScoped2 = FindAct(kv->GetString("FireScoped2", "None"));
		animData.FireScoped3 = FindAct(kv->GetString("FireScoped3", "None"));
		animData.FireScoped4 = FindAct(kv->GetString("FireScoped4", "None"));
		animData.FireScopedSilenced1 = FindAct(kv->GetString("FireScopedSilenced1", "None"));
		animData.FireScopedSilenced2 = FindAct(kv->GetString("FireScopedSilenced2", "None"));
		animData.FireScopedSilenced3 = FindAct(kv->GetString("FireScopedSilenced3", "None"));
		animData.FireScopedSilenced4 = FindAct(kv->GetString("FireScopedSilenced4", "None"));
		animData.FireSecondary1 = FindAct(kv->GetString("FireSecondary1", "None"));
		animData.FireSecondary2 = FindAct(kv->GetString("FireSecondary2", "None"));
		animData.FireSecondary3 = FindAct(kv->GetString("FireSecondary3", "None"));
		animData.FireSecondary4 = FindAct(kv->GetString("FireSecondary4", "None"));
		animData.FireSecondaryLast = FindAct(kv->GetString("FireSecondaryLast", "None"));
		animData.FireSecondaryCharging = FindAct(kv->GetString("FireSecondaryCharging", "None"));
		animData.FireSecondaryIronsighted1 = FindAct(kv->GetString("FireSecondaryIronsighted1", "None"));
		animData.FireSecondaryIronsighted2 = FindAct(kv->GetString("FireSecondaryIronsighted2", "None"));
		animData.FireSecondaryIronsighted3 = FindAct(kv->GetString("FireSecondaryIronsighted3", "None"));
		animData.FireSecondaryIronsighted4 = FindAct(kv->GetString("FireSecondaryIronsighted4", "None"));
		animData.InspectAnimation = FindAct(kv->GetString("InspectAnimation", "None"));
		animData.InspectSilencedAnimation = FindAct(kv->GetString("InspectSilencedAnimation", "None"));
		animData.OverhaulAnimation = FindAct(kv->GetString("OverhaulAnimation", "None"));
		animData.ShotgunFireAnimation = FindAct(kv->GetString("ShotgunFireAnimation", "None"));
		animData.ShotgunPumpAnimation = FindAct(kv->GetString("ShotgunPumpAnimation", "None"));
		animData.ShotgunDoublePumpAnimation = FindAct(kv->GetString("ShotgunDoublePumpAnimation", "None"));
		animData.ShotgunStartReloadAnimation = FindAct(kv->GetString("ShotgunStartReloadAnimation", "None"));
		animData.ShotgunFillClipAnimation = FindAct(kv->GetString("ShotgunFillClipAnimation", "None"));
		animData.ShotgunStopReloadAnimation = FindAct(kv->GetString("ShotgunStopReloadAnimation", "None"));
		animData.RunAnimation = FindAct(kv->GetString("RunAnimation", "None"));
		animData.WalkAnimation = FindAct(kv->GetString("WalkAnimation", "None"));
		animData.WallAnimation = FindAct(kv->GetString("WallAnimation", "None"));
		//animData.ReloadTwoRounds = FindAct(kv->GetString("ReloadTwoRounds", "None"));
		animData.ReloadMidEmptyAnimation = FindAct(kv->GetString("ReloadMidEmptyAnimation", "None"));
		animData.ReloadFullEmptyAnimation = FindAct(kv->GetString("ReloadFullEmptyAnimation", "None"));
		//animData.BMSEmptyReloadAnimation = FindAct(kv->GetString("BMSEmptyReloadAnimation", "None"));
		animData.ReloadDefaultAnimation = FindAct(kv->GetString("ReloadDefaultAnimation", "None"));
		animData.ReloadSilencedAnimation = FindAct(kv->GetString("ReloadSilencedAnimation", "None"));
		animData.HolsterAnimation = FindAct(kv->GetString("HolsterAnimation", "None"));
		animData.HolsterMode1Animation = FindAct(kv->GetString("HolsterMode1Animation", "None"));
		animData.HolsterMode2Animation = FindAct(kv->GetString("HolsterMode2Animation", "None"));
		animData.HolsterMode3Animation = FindAct(kv->GetString("HolsterMode3Animation", "None"));
		animData.PumpAnimation = FindAct(kv->GetString("PumpAnimation", "None"));
		animData.MeleeIdle = FindAct(kv->GetString("MeleeIdle", "None"));
		animData.MeleeAttack1 = FindAct(kv->GetString("MeleeAttack1", "None"));
		animData.MeleeAttack2 = FindAct(kv->GetString("MeleeAttack2", "None"));
		animData.MeleeMiss1 = FindAct(kv->GetString("MeleeMiss1", "None"));
		animData.MeleeMiss2 = FindAct(kv->GetString("MeleeMiss2", "None"));
		animData.MeleeSwing1 = FindAct(kv->GetString("MeleeSwing1", "None"));
		animData.MeleeSwing2 = FindAct(kv->GetString("MeleeSwing2", "None"));

		animData.WeaponSwitchAnim = FindAct(kv->GetString("weapon_switch_animation", "None"));

		animData.SwingAnim = FindAct(kv->GetString("SwingAnimation", "None"));
	}
	else
	{
		/*animData.DrawTwoRounds
		animData.IdleTwoRounds
		animData.WallTwoRounds
		animData.RunTwoRounds
		animData.WalkTwoRounds*/

		animData.DryFireAnimation = (Activity)0;
		animData.DrawAnimation = (Activity)0;
		animData.DrawSilencedAnimation = (Activity)0;
		animData.DrawEmptyAnimation = (Activity)0;
		animData.DrawEmptySilencedAnimation = (Activity)0;
		animData.ThrowPullUp = (Activity)0;
		animData.ThrowPullDown = (Activity)0;
		animData.ThrowPrimary = (Activity)0;
		animData.ThrowSecondary = (Activity)0;
		animData.UseSpecialAnimations = false;
		animData.UseIronSightAnimations = false;
		animData.UseHalfFullMagAnimations = false;
		animData.UsePistolRefireChecker = false;
		animData.FirstDrawAnimation = (Activity)0;
		animData.ZeroIdleAnim = false;
		animData.CustomIdleAnimOnIronSightOrScope = (Activity)0;
		animData.ReloadWaitWhileAnimation = 0;
		animData.IronsightIdle = (Activity)0;
		animData.IdleAlmostEmpty = (Activity)0;
		animData.IdleFullEmpty = (Activity)0;
		animData.IdleAnimation = (Activity)0;
		animData.WallAlmostEmpty = (Activity)0;
		animData.WallFullEmpty = (Activity)0;
		animData.RunAlmostEmpty = (Activity)0;
		animData.RunFullEmpty = (Activity)0;
		animData.WalkAlmostEmpty = (Activity)0;
		animData.WalkFullEmpty = (Activity)0;
		animData.IronAlmostEmpty = (Activity)0;
		animData.IronFullEmpty = (Activity)0;
		animData.LoweredAlmostEmpty = (Activity)0;
		animData.LoweredFullEmpty = (Activity)0;
		animData.LoweredAnimation = (Activity)0;
		animData.HolsterAlmostEmpty = (Activity)0;
		animData.HolsterFullEmpty = (Activity)0;
		animData.FirePrimaryTwoRounds = (Activity)0;
		animData.FirePrimaryAlmostEmpty = (Activity)0;
		animData.FirePrimaryCompleteEmpty = (Activity)0;
		animData.FireIronsightedTwoRounds = (Activity)0;
		animData.FireIronsightedAlmostEmpty = (Activity)0;
		animData.FireIronsightedCompleteEmpty = (Activity)0;
		animData.FireScopedTwoRounds = (Activity)0;
		animData.FireScopedAlmostEmpty = (Activity)0;
		animData.FireScopedCompleteEmpty = (Activity)0;
		animData.FirePrimary1 = (Activity)0;
		animData.FirePrimary2 = (Activity)0;
		animData.FirePrimary3 = (Activity)0;
		animData.FirePrimary4 = (Activity)0;
		animData.FirePrimarySilenced1 = (Activity)0;
		animData.FirePrimarySilenced2 = (Activity)0;
		animData.FirePrimarySilenced3 = (Activity)0;
		animData.FirePrimarySilenced4 = (Activity)0;
		animData.FireIronsighted1 = (Activity)0;
		animData.FireIronsighted2 = (Activity)0;
		animData.FireIronsighted3 = (Activity)0;
		animData.FireIronsighted4 = (Activity)0;
		animData.FireIronsightedSilenced1 = (Activity)0;
		animData.FireIronsightedSilenced2 = (Activity)0;
		animData.FireIronsightedSilenced3 = (Activity)0;
		animData.FireIronsightedSilenced4 = (Activity)0;
		animData.FireScoped1 = (Activity)0;
		animData.FireScoped2 = (Activity)0;
		animData.FireScoped3 = (Activity)0;
		animData.FireScoped4 = (Activity)0;
		animData.FireScopedSilenced1 = (Activity)0;
		animData.FireScopedSilenced2 = (Activity)0;
		animData.FireScopedSilenced3 = (Activity)0;
		animData.FireScopedSilenced4 = (Activity)0;
		animData.FirePrimarySpecial = (Activity)0;
		animData.FireSecondary1 = (Activity)0;
		animData.FireSecondary2 = (Activity)0;
		animData.FireSecondary3 = (Activity)0;
		animData.FireSecondary4 = (Activity)0;
		animData.FireSecondaryLast = (Activity)0;
		animData.FireSecondaryCharging = (Activity)0;
		animData.FireSecondaryIronsighted1 = (Activity)0;
		animData.FireSecondaryIronsighted2 = (Activity)0;
		animData.FireSecondaryIronsighted3 = (Activity)0;
		animData.FireSecondaryIronsighted4 = (Activity)0;
		animData.InspectAnimation = (Activity)0;
		animData.InspectSilencedAnimation = (Activity)0;
		animData.OverhaulAnimation = (Activity)0;
		animData.ShotgunFireAnimation = (Activity)0;
		animData.ShotgunPumpAnimation = (Activity)0;
		animData.ShotgunDoublePumpAnimation = (Activity)0;
		animData.ShotgunStartReloadAnimation = (Activity)0;
		animData.ShotgunFillClipAnimation = (Activity)0;
		animData.ShotgunStopReloadAnimation = (Activity)0;
		animData.RunAnimation = (Activity)0;
		animData.WalkAnimation = (Activity)0;
		animData.WallAnimation = (Activity)0;
		animData.ReloadMidEmptyAnimation = (Activity)0;
		animData.ReloadFullEmptyAnimation = (Activity)0;
		//animData.BMSEmptyReloadAnimation = (Activity)0;
		animData.ReloadDefaultAnimation = (Activity)0;
		animData.ReloadSilencedAnimation = (Activity)0;
		animData.HolsterAnimation = (Activity)0;
		animData.HolsterMode1Animation = (Activity)0;
		animData.HolsterMode2Animation = (Activity)0;
		animData.HolsterMode3Animation = (Activity)0;
		animData.PumpAnimation = (Activity)0;
		animData.MeleeIdle = (Activity)0;
		animData.MeleeAttack1 = (Activity)0;
		animData.MeleeAttack2 = (Activity)0;
		animData.MeleeMiss1 = (Activity)0;
		animData.MeleeMiss2 = (Activity)0;
		animData.MeleeSwing1 = (Activity)0;
		animData.MeleeSwing2 = (Activity)0;

		animData.WeaponSwitchAnim = (Activity)0;

		animData.SwingAnim = (Activity)0;
	}
	return animData;
}

void FileWeaponInfo_t::Parse( KeyValues *pKeyValuesData, const char *szWeaponName )
{
	if (bParsedScript)
	{
		ParseCustomData(pKeyValuesData, szWeaponName);
		return;
	}
	ParseCustomData(pKeyValuesData, szWeaponName);

	viewbob_model_scale = pKeyValuesData->GetFloat("viewbob_model_scale", 0);


	MeleeStunbattonParticleEffects = (Activity)pKeyValuesData->GetInt("MeleeStunbattonParticleEffects", 0);

	AllowIronSight = pKeyValuesData->GetInt("AllowIronSight", 1);
	AllowFreeAim = pKeyValuesData->GetInt("AllowFreeAim", 0);
	AllowShellEjectSmokeFlash = pKeyValuesData->GetInt("AllowShellEjectSmokeFlash", AllowShellEjectSmokeFlash);


	PlayerDisableSprint = pKeyValuesData->GetBool("PlayerDisableSprint", 0);
	PlayerSpeedWalkKoefficient = pKeyValuesData->GetFloat("PlayerSpeedWalkKoefficient", 0);
	PlayerSpeedRunKoefficient = pKeyValuesData->GetFloat("PlayerSpeedRunKoefficient", 0);
	PlayerSpeedCrouchKoefficient = pKeyValuesData->GetFloat("PlayerSpeedCrouchKoefficient", 0);
	// Okay, we tried at least once to look this up...
	bParsedScript = true;

	// Classname
	Q_strncpy( szClassName, szWeaponName, MAX_WEAPON_STRING );
	// Printable name
	Q_strncpy( szPrintName, pKeyValuesData->GetString( "printname", WEAPON_PRINTNAME_MISSING ), MAX_WEAPON_STRING );
	// View model & world model
	Q_strncpy( szViewModel, pKeyValuesData->GetString( "viewmodel" ), MAX_WEAPON_STRING );

	//szAdditionalViewModel = AllocPooledString(pKeyValuesData->GetString("additional_viewmodel", ""));
	Q_strncpy(szAdditionalViewModel, pKeyValuesData->GetString("additional_viewmodel"), MAX_WEAPON_STRING);
	char emp1[2] = "";
	if (szAdditionalViewModel != NULL && szAdditionalViewModel != emp1)
		CBaseEntity::PrecacheModel(pKeyValuesData->GetString("additional_viewmodel", ""));

	Q_strncpy( szWorldModel, pKeyValuesData->GetString( "playermodel" ), MAX_WEAPON_STRING );
	Q_strncpy(szAnimationPrefix, pKeyValuesData->GetString("anim_prefix"), MAX_WEAPON_STRING);

	if (cvar->FindVar("oc_player_allow_fast_gren_throw")->GetInt() && weaponType == TYPE_GRENADE)
	{
		iSlot = -1;
		iPosition = -1;
	}
	else
	{
		iSlot = pKeyValuesData->GetInt("bucket", 0);
		iPosition = pKeyValuesData->GetInt("bucket_position", 0);
	}

	m_bReservedSlot = pKeyValuesData->GetBool("bucket_reserved", 0);

	// BriJee OVR: Silent w_ model.
	Q_strncpy(szSilentModel, pKeyValuesData->GetString("playermodel_silent"), sizeof(szSilentModel));
	if (szSilentModel != NULL && szSilentModel != emp1)
		CBaseEntity::PrecacheModel(pKeyValuesData->GetString("playermodel_silent", ""));

	//Q_strncpy(iMagName, pKeyValuesData->GetString("MagName"), sizeof(iMagName));

	// Use the console (X360) buckets if hud_fastswitch is set to 2.
#ifdef CLIENT_DLL
	if ( hud_fastswitch.GetInt() == 2 )
#else
	if ( IsX360() )
#endif
	{
		iSlot = pKeyValuesData->GetInt( "bucket_360", iSlot );
		iPosition = pKeyValuesData->GetInt( "bucket_position_360", iPosition );
	}
	iMaxClip1 = pKeyValuesData->GetInt( "clip_size", WEAPON_NOCLIP );					// Max primary clips gun can hold (assume they don't use clips by default)
	iMaxClip2 = pKeyValuesData->GetInt( "clip2_size", WEAPON_NOCLIP );					// Max secondary clips gun can hold (assume they don't use clips by default)

	iDefaultClip1 = pKeyValuesData->GetInt( "default_clip", iMaxClip1 );		// amount of primary ammo placed in the primary clip when it's picked up
	iDefaultClip2 = pKeyValuesData->GetInt( "default_clip2", iMaxClip2 );		// amount of secondary ammo placed in the secondary clip when it's picked up
	iWeight = pKeyValuesData->GetInt( "weight", 0 );

	iRumbleEffect = pKeyValuesData->GetInt( "rumble", -1 );
	
	// LAME old way to specify item flags.
	// Weapon scripts should use the flag names.
	iFlags = pKeyValuesData->GetInt( "item_flags", ITEM_FLAG_LIMITINWORLD );

	for ( int i=0; i < ARRAYSIZE( g_ItemFlags ); i++ )
	{
		int iVal = pKeyValuesData->GetInt( g_ItemFlags[i].m_pFlagName, -1 );
		if ( iVal == 0 )
		{
			iFlags &= ~g_ItemFlags[i].m_iFlagValue;
		}
		else if ( iVal == 1 )
		{
			iFlags |= g_ItemFlags[i].m_iFlagValue;
		}
	}


	bShowUsageHint = ( pKeyValuesData->GetInt( "showusagehint", 0 ) != 0 ) ? true : false;
	bAutoSwitchTo = ( pKeyValuesData->GetInt( "autoswitchto", 1 ) != 0 ) ? true : false;
	bAutoSwitchFrom = ( pKeyValuesData->GetInt( "autoswitchfrom", 1 ) != 0 ) ? true : false;
	m_bBuiltRightHanded = ( pKeyValuesData->GetInt( "BuiltRightHanded", 1 ) != 0 ) ? true : false;
	m_bAllowFlipping = ( pKeyValuesData->GetInt( "AllowFlipping", 1 ) != 0 ) ? true : false;
	m_bMeleeWeapon = ( pKeyValuesData->GetInt( "MeleeWeapon", 0 ) != 0 ) ? true : false;

#if defined(_DEBUG) && defined(HL2_CLIENT_DLL)
	// make sure two weapons aren't in the same slot & position
	if ( iSlot >= MAX_WEAPON_SLOTS ||
		iPosition >= MAX_WEAPON_POSITIONS )
	{
		Warning( "Invalid weapon slot or position [slot %d/%d max], pos[%d/%d max]\n",
			iSlot, MAX_WEAPON_SLOTS - 1, iPosition, MAX_WEAPON_POSITIONS - 1 );
	}
	else
	{
		if (g_bUsedWeaponSlots[iSlot][iPosition])
		{
			Warning( "Duplicately assigned weapon slots in selection hud:  %s (%d, %d)\n", szPrintName, iSlot, iPosition );
		}
		g_bUsedWeaponSlots[iSlot][iPosition] = true;
	}
#endif

	// Primary ammo used
	const char *pAmmo = pKeyValuesData->GetString( "primary_ammo", "None" );
	if ( strcmp("None", pAmmo) == 0 )
		Q_strncpy( szAmmo1, "", sizeof( szAmmo1 ) );
	else
		Q_strncpy( szAmmo1, pAmmo, sizeof( szAmmo1 )  );
	iAmmoType = GetAmmoDef()->Index( szAmmo1 );
	
	// Secondary ammo used
	pAmmo = pKeyValuesData->GetString( "secondary_ammo", "None" );
	if ( strcmp("None", pAmmo) == 0)
		Q_strncpy( szAmmo2, "", sizeof( szAmmo2 ) );
	else
		Q_strncpy( szAmmo2, pAmmo, sizeof( szAmmo2 )  );
	iAmmo2Type = GetAmmoDef()->Index( szAmmo2 );

	// Now read the weapon sounds
	memset( aShootSounds, 0, sizeof( aShootSounds ) );
	KeyValues *pSoundData = pKeyValuesData->FindKey( "SoundData" );
	if (pSoundData)
	{
		KeyValues *pLoop = pSoundData->FindKey("LoopSound");
		if (pLoop)
		{
			Q_strncpy(ShootLoopingSound, pLoop->GetString("LoopShooting", ""), MAX_WEAPON_STRING);
			if (Q_strlen(ShootLoopingSound) <= 1)
			{
				allowLoopSound = false;
			}
			else
			{
				allowLoopSound = true;
				CBaseEntity::PrecacheScriptSound(ShootLoopingSound);

				LoopSoundBurstPitchMultiplier = pLoop->GetFloat("LoopSoundBurstPitchMultiplier", 1.0f);

				LoopSoundSlowMoPitchDivider = pLoop->GetFloat("LoopSoundSlowMoPitchDivider", 0.125);

				Q_strncpy(EndLoopingSound, pLoop->GetString("EndLoopShooting", ""), MAX_WEAPON_STRING);

				if (Q_strlen(EndLoopingSound) > 0)
				{
					CBaseEntity::PrecacheScriptSound(EndLoopingSound);
				}
			}

			Q_strncpy(ShootLoopingSilencerSound, pLoop->GetString("LoopSilencerShooting", ""), MAX_WEAPON_STRING);
			if (Q_strlen(ShootLoopingSilencerSound) <= 1)
			{
				allowLoopSilencerSound = false;
			}
			else
			{
				allowLoopSilencerSound = true;
				CBaseEntity::PrecacheScriptSound(ShootLoopingSilencerSound);

				LoopSoundBurstPitchMultiplier = pLoop->GetFloat("LoopSoundBurstPitchMultiplier", 1.0f);
				LoopSilencerSoundSlowMoPitchDivider = pLoop->GetFloat("LoopSilencerSoundSlowMoPitchDivider", 0.125);

				Q_strncpy(EndLoopingSilencerSound, pLoop->GetString("EndLoopSilencerShooting", ""), MAX_WEAPON_STRING);

				if (Q_strlen(EndLoopingSilencerSound) > 0)
				{
					CBaseEntity::PrecacheScriptSound(EndLoopingSilencerSound);
				}
			}
		}
		else
		{
			Q_strncpy(ShootLoopingSound, "", MAX_WEAPON_STRING);
			Q_strncpy(EndLoopingSound, "", MAX_WEAPON_STRING);
			Q_strncpy(ShootLoopingSilencerSound, "", MAX_WEAPON_STRING);
			Q_strncpy(EndLoopingSilencerSound, "", MAX_WEAPON_STRING);
			allowLoopSound = false;
			allowLoopSilencerSound = false;
			LoopSoundBurstPitchMultiplier = 1.0f;
			LoopSoundSlowMoPitchDivider = 0.125f;
			LoopSilencerSoundSlowMoPitchDivider = 0.125f;
		}

		for (int i = EMPTY; i < NUM_SHOOT_SOUND_TYPES; i++)
		{
			const char *soundname = pSoundData->GetString(pWeaponSoundCategories[i]);
			if (soundname && soundname[0])
			{
				Q_strncpy(aShootSounds[i], soundname, MAX_WEAPON_STRING);
			}
		}
	}
	else
	{
		Q_strncpy(ShootLoopingSound, "", MAX_WEAPON_STRING);
		Q_strncpy(EndLoopingSound, "", MAX_WEAPON_STRING);
		Q_strncpy(ShootLoopingSilencerSound, "", MAX_WEAPON_STRING);
		Q_strncpy(EndLoopingSilencerSound, "", MAX_WEAPON_STRING);
		allowLoopSound = false;
		allowLoopSilencerSound = false;
		LoopSoundBurstPitchMultiplier = 1.0f;
		LoopSoundSlowMoPitchDivider = 0.125f;
		LoopSilencerSoundSlowMoPitchDivider = 0.125f;
	}
}

